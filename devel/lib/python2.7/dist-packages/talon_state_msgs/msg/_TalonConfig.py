# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from talon_state_msgs/TalonConfig.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class TalonConfig(genpy.Message):
  _md5sum = "c581b95d041ee8a7724c07ef2b96b2da"
  _type = "talon_state_msgs/TalonConfig"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header

string[] name
int8[] can_id
float64[] feedback_coefficient
string[]  feedback_sensor
string[]  remote_feedback_sensor
int8[]    remote_feedback_device_id0
string[]  remote_feedback_filter0
int8[]    remote_feedback_device_id1
string[]  remote_feedback_filter1
string[]  sensor_term_sum0
string[]  sensor_term_sum1
string[]  sensor_term_diff0
string[]  sensor_term_diff1
int32[]   encoder_ticks_per_rotation
int32[]   pid_slot
float64[] pid_p0
float64[] pid_i0
float64[] pid_d0
float64[] pid_f0
int32[] pid_izone0
int32[] pid_allowable_closed_loop_error0
float64[] pid_max_integral_accumulator0
float64[] pid_closed_loop_peak_output0
int32[]   pid_closed_loop_period0
float64[] pid_p1
float64[] pid_i1
float64[] pid_d1
float64[] pid_f1
int32[] pid_izone1
int32[] pid_allowable_closed_loop_error1
float64[] pid_max_integral_accumulator1
float64[] pid_closed_loop_peak_output1
int32[]   pid_closed_loop_period1
float64[] pid_p2
float64[] pid_i2
float64[] pid_d2
float64[] pid_f2
int32[] pid_izone2
int32[] pid_allowable_closed_loop_error2
float64[] pid_max_integral_accumulator2
float64[] pid_closed_loop_peak_output2
int32[]   pid_closed_loop_period2
float64[] pid_p3
float64[] pid_i3
float64[] pid_d3
float64[] pid_f3
int32[] pid_izone3
int32[] pid_allowable_closed_loop_error3
float64[] pid_max_integral_accumulator3
float64[] pid_closed_loop_peak_output3
int32[]   pid_closed_loop_period3
bool[]    aux_pid_polarity
bool[] invert
bool[] sensorPhase
string[] neutral_mode
float64[] closed_loop_ramp
float64[] open_loop_ramp
float64[] peak_output_forward
float64[] peak_output_reverse
float64[] nominal_output_forward
float64[] nominal_output_reverse
float64[] neutral_deadband
float64[] voltage_compensation_saturation
int32[]   voltage_measurement_filter
bool[]    voltage_compensation_enable
int32[]   velocity_measurement_period
int32[]   velocity_measurement_window
string[]  limit_switch_local_forward_source
string[]  limit_switch_local_forward_normal
string[]  limit_switch_local_reverse_source
string[]  limit_switch_local_reverse_normal
string[]  limit_switch_remote_forward_source
string[]  limit_switch_remote_forward_normal
uint8[]   limit_switch_remote_forward_id
string[]  limit_switch_remote_reverse_source
string[]  limit_switch_remote_reverse_normal
uint8[]   limit_switch_remote_reverse_id
float64[] softlimit_forward_threshold
bool[]    softlimit_forward_enable
float64[] softlimit_reverse_threshold
bool[]    softlimit_reverse_enable
bool[]    softlimits_override_enable
int32[]   current_limit_peak_amps
int32[]   current_limit_peak_msec
int32[]   current_limit_continuous_amps
bool[]    current_limit_enable
float64[] motion_cruise_velocity
float64[] motion_acceleration
uint8[]   motion_s_curve_strength
uint8[]   status_1_general_period
uint8[]   status_2_feedback0_period
uint8[]   status_3_quadrature_period
uint8[]   status_4_aintempvbat_period
uint8[]   status_6_misc_period
uint8[]   status_7_commstatus_period
uint8[]   status_8_pulsewidth_period
uint8[]   status_9_motprofbuffer_period
uint8[]   status_10_motionmagic_period
uint8[]   status_11_uartgadgeteer_period
uint8[]   status_12_feedback1_period
uint8[]   status_13_base_pidf0_period
uint8[]   status_14_turn_pidf1_period
uint8[]   status_15_firmwareapistatus_period
uint8[]   control_3_general_period
uint8[]   control_4_advanced_period
uint8[]   control_5_feedbackoutputoverride_period
uint8[]   control_6_motprofaddtrajpoint_period
float64[] motion_profile_trajectory_period
float64[] conversion_factor
string[]  firmware_version
bool[]    water_game


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id
"""
  __slots__ = ['header','name','can_id','feedback_coefficient','feedback_sensor','remote_feedback_sensor','remote_feedback_device_id0','remote_feedback_filter0','remote_feedback_device_id1','remote_feedback_filter1','sensor_term_sum0','sensor_term_sum1','sensor_term_diff0','sensor_term_diff1','encoder_ticks_per_rotation','pid_slot','pid_p0','pid_i0','pid_d0','pid_f0','pid_izone0','pid_allowable_closed_loop_error0','pid_max_integral_accumulator0','pid_closed_loop_peak_output0','pid_closed_loop_period0','pid_p1','pid_i1','pid_d1','pid_f1','pid_izone1','pid_allowable_closed_loop_error1','pid_max_integral_accumulator1','pid_closed_loop_peak_output1','pid_closed_loop_period1','pid_p2','pid_i2','pid_d2','pid_f2','pid_izone2','pid_allowable_closed_loop_error2','pid_max_integral_accumulator2','pid_closed_loop_peak_output2','pid_closed_loop_period2','pid_p3','pid_i3','pid_d3','pid_f3','pid_izone3','pid_allowable_closed_loop_error3','pid_max_integral_accumulator3','pid_closed_loop_peak_output3','pid_closed_loop_period3','aux_pid_polarity','invert','sensorPhase','neutral_mode','closed_loop_ramp','open_loop_ramp','peak_output_forward','peak_output_reverse','nominal_output_forward','nominal_output_reverse','neutral_deadband','voltage_compensation_saturation','voltage_measurement_filter','voltage_compensation_enable','velocity_measurement_period','velocity_measurement_window','limit_switch_local_forward_source','limit_switch_local_forward_normal','limit_switch_local_reverse_source','limit_switch_local_reverse_normal','limit_switch_remote_forward_source','limit_switch_remote_forward_normal','limit_switch_remote_forward_id','limit_switch_remote_reverse_source','limit_switch_remote_reverse_normal','limit_switch_remote_reverse_id','softlimit_forward_threshold','softlimit_forward_enable','softlimit_reverse_threshold','softlimit_reverse_enable','softlimits_override_enable','current_limit_peak_amps','current_limit_peak_msec','current_limit_continuous_amps','current_limit_enable','motion_cruise_velocity','motion_acceleration','motion_s_curve_strength','status_1_general_period','status_2_feedback0_period','status_3_quadrature_period','status_4_aintempvbat_period','status_6_misc_period','status_7_commstatus_period','status_8_pulsewidth_period','status_9_motprofbuffer_period','status_10_motionmagic_period','status_11_uartgadgeteer_period','status_12_feedback1_period','status_13_base_pidf0_period','status_14_turn_pidf1_period','status_15_firmwareapistatus_period','control_3_general_period','control_4_advanced_period','control_5_feedbackoutputoverride_period','control_6_motprofaddtrajpoint_period','motion_profile_trajectory_period','conversion_factor','firmware_version','water_game']
  _slot_types = ['std_msgs/Header','string[]','int8[]','float64[]','string[]','string[]','int8[]','string[]','int8[]','string[]','string[]','string[]','string[]','string[]','int32[]','int32[]','float64[]','float64[]','float64[]','float64[]','int32[]','int32[]','float64[]','float64[]','int32[]','float64[]','float64[]','float64[]','float64[]','int32[]','int32[]','float64[]','float64[]','int32[]','float64[]','float64[]','float64[]','float64[]','int32[]','int32[]','float64[]','float64[]','int32[]','float64[]','float64[]','float64[]','float64[]','int32[]','int32[]','float64[]','float64[]','int32[]','bool[]','bool[]','bool[]','string[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','int32[]','bool[]','int32[]','int32[]','string[]','string[]','string[]','string[]','string[]','string[]','uint8[]','string[]','string[]','uint8[]','float64[]','bool[]','float64[]','bool[]','bool[]','int32[]','int32[]','int32[]','bool[]','float64[]','float64[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','uint8[]','float64[]','float64[]','string[]','bool[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,name,can_id,feedback_coefficient,feedback_sensor,remote_feedback_sensor,remote_feedback_device_id0,remote_feedback_filter0,remote_feedback_device_id1,remote_feedback_filter1,sensor_term_sum0,sensor_term_sum1,sensor_term_diff0,sensor_term_diff1,encoder_ticks_per_rotation,pid_slot,pid_p0,pid_i0,pid_d0,pid_f0,pid_izone0,pid_allowable_closed_loop_error0,pid_max_integral_accumulator0,pid_closed_loop_peak_output0,pid_closed_loop_period0,pid_p1,pid_i1,pid_d1,pid_f1,pid_izone1,pid_allowable_closed_loop_error1,pid_max_integral_accumulator1,pid_closed_loop_peak_output1,pid_closed_loop_period1,pid_p2,pid_i2,pid_d2,pid_f2,pid_izone2,pid_allowable_closed_loop_error2,pid_max_integral_accumulator2,pid_closed_loop_peak_output2,pid_closed_loop_period2,pid_p3,pid_i3,pid_d3,pid_f3,pid_izone3,pid_allowable_closed_loop_error3,pid_max_integral_accumulator3,pid_closed_loop_peak_output3,pid_closed_loop_period3,aux_pid_polarity,invert,sensorPhase,neutral_mode,closed_loop_ramp,open_loop_ramp,peak_output_forward,peak_output_reverse,nominal_output_forward,nominal_output_reverse,neutral_deadband,voltage_compensation_saturation,voltage_measurement_filter,voltage_compensation_enable,velocity_measurement_period,velocity_measurement_window,limit_switch_local_forward_source,limit_switch_local_forward_normal,limit_switch_local_reverse_source,limit_switch_local_reverse_normal,limit_switch_remote_forward_source,limit_switch_remote_forward_normal,limit_switch_remote_forward_id,limit_switch_remote_reverse_source,limit_switch_remote_reverse_normal,limit_switch_remote_reverse_id,softlimit_forward_threshold,softlimit_forward_enable,softlimit_reverse_threshold,softlimit_reverse_enable,softlimits_override_enable,current_limit_peak_amps,current_limit_peak_msec,current_limit_continuous_amps,current_limit_enable,motion_cruise_velocity,motion_acceleration,motion_s_curve_strength,status_1_general_period,status_2_feedback0_period,status_3_quadrature_period,status_4_aintempvbat_period,status_6_misc_period,status_7_commstatus_period,status_8_pulsewidth_period,status_9_motprofbuffer_period,status_10_motionmagic_period,status_11_uartgadgeteer_period,status_12_feedback1_period,status_13_base_pidf0_period,status_14_turn_pidf1_period,status_15_firmwareapistatus_period,control_3_general_period,control_4_advanced_period,control_5_feedbackoutputoverride_period,control_6_motprofaddtrajpoint_period,motion_profile_trajectory_period,conversion_factor,firmware_version,water_game

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(TalonConfig, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.name is None:
        self.name = []
      if self.can_id is None:
        self.can_id = []
      if self.feedback_coefficient is None:
        self.feedback_coefficient = []
      if self.feedback_sensor is None:
        self.feedback_sensor = []
      if self.remote_feedback_sensor is None:
        self.remote_feedback_sensor = []
      if self.remote_feedback_device_id0 is None:
        self.remote_feedback_device_id0 = []
      if self.remote_feedback_filter0 is None:
        self.remote_feedback_filter0 = []
      if self.remote_feedback_device_id1 is None:
        self.remote_feedback_device_id1 = []
      if self.remote_feedback_filter1 is None:
        self.remote_feedback_filter1 = []
      if self.sensor_term_sum0 is None:
        self.sensor_term_sum0 = []
      if self.sensor_term_sum1 is None:
        self.sensor_term_sum1 = []
      if self.sensor_term_diff0 is None:
        self.sensor_term_diff0 = []
      if self.sensor_term_diff1 is None:
        self.sensor_term_diff1 = []
      if self.encoder_ticks_per_rotation is None:
        self.encoder_ticks_per_rotation = []
      if self.pid_slot is None:
        self.pid_slot = []
      if self.pid_p0 is None:
        self.pid_p0 = []
      if self.pid_i0 is None:
        self.pid_i0 = []
      if self.pid_d0 is None:
        self.pid_d0 = []
      if self.pid_f0 is None:
        self.pid_f0 = []
      if self.pid_izone0 is None:
        self.pid_izone0 = []
      if self.pid_allowable_closed_loop_error0 is None:
        self.pid_allowable_closed_loop_error0 = []
      if self.pid_max_integral_accumulator0 is None:
        self.pid_max_integral_accumulator0 = []
      if self.pid_closed_loop_peak_output0 is None:
        self.pid_closed_loop_peak_output0 = []
      if self.pid_closed_loop_period0 is None:
        self.pid_closed_loop_period0 = []
      if self.pid_p1 is None:
        self.pid_p1 = []
      if self.pid_i1 is None:
        self.pid_i1 = []
      if self.pid_d1 is None:
        self.pid_d1 = []
      if self.pid_f1 is None:
        self.pid_f1 = []
      if self.pid_izone1 is None:
        self.pid_izone1 = []
      if self.pid_allowable_closed_loop_error1 is None:
        self.pid_allowable_closed_loop_error1 = []
      if self.pid_max_integral_accumulator1 is None:
        self.pid_max_integral_accumulator1 = []
      if self.pid_closed_loop_peak_output1 is None:
        self.pid_closed_loop_peak_output1 = []
      if self.pid_closed_loop_period1 is None:
        self.pid_closed_loop_period1 = []
      if self.pid_p2 is None:
        self.pid_p2 = []
      if self.pid_i2 is None:
        self.pid_i2 = []
      if self.pid_d2 is None:
        self.pid_d2 = []
      if self.pid_f2 is None:
        self.pid_f2 = []
      if self.pid_izone2 is None:
        self.pid_izone2 = []
      if self.pid_allowable_closed_loop_error2 is None:
        self.pid_allowable_closed_loop_error2 = []
      if self.pid_max_integral_accumulator2 is None:
        self.pid_max_integral_accumulator2 = []
      if self.pid_closed_loop_peak_output2 is None:
        self.pid_closed_loop_peak_output2 = []
      if self.pid_closed_loop_period2 is None:
        self.pid_closed_loop_period2 = []
      if self.pid_p3 is None:
        self.pid_p3 = []
      if self.pid_i3 is None:
        self.pid_i3 = []
      if self.pid_d3 is None:
        self.pid_d3 = []
      if self.pid_f3 is None:
        self.pid_f3 = []
      if self.pid_izone3 is None:
        self.pid_izone3 = []
      if self.pid_allowable_closed_loop_error3 is None:
        self.pid_allowable_closed_loop_error3 = []
      if self.pid_max_integral_accumulator3 is None:
        self.pid_max_integral_accumulator3 = []
      if self.pid_closed_loop_peak_output3 is None:
        self.pid_closed_loop_peak_output3 = []
      if self.pid_closed_loop_period3 is None:
        self.pid_closed_loop_period3 = []
      if self.aux_pid_polarity is None:
        self.aux_pid_polarity = []
      if self.invert is None:
        self.invert = []
      if self.sensorPhase is None:
        self.sensorPhase = []
      if self.neutral_mode is None:
        self.neutral_mode = []
      if self.closed_loop_ramp is None:
        self.closed_loop_ramp = []
      if self.open_loop_ramp is None:
        self.open_loop_ramp = []
      if self.peak_output_forward is None:
        self.peak_output_forward = []
      if self.peak_output_reverse is None:
        self.peak_output_reverse = []
      if self.nominal_output_forward is None:
        self.nominal_output_forward = []
      if self.nominal_output_reverse is None:
        self.nominal_output_reverse = []
      if self.neutral_deadband is None:
        self.neutral_deadband = []
      if self.voltage_compensation_saturation is None:
        self.voltage_compensation_saturation = []
      if self.voltage_measurement_filter is None:
        self.voltage_measurement_filter = []
      if self.voltage_compensation_enable is None:
        self.voltage_compensation_enable = []
      if self.velocity_measurement_period is None:
        self.velocity_measurement_period = []
      if self.velocity_measurement_window is None:
        self.velocity_measurement_window = []
      if self.limit_switch_local_forward_source is None:
        self.limit_switch_local_forward_source = []
      if self.limit_switch_local_forward_normal is None:
        self.limit_switch_local_forward_normal = []
      if self.limit_switch_local_reverse_source is None:
        self.limit_switch_local_reverse_source = []
      if self.limit_switch_local_reverse_normal is None:
        self.limit_switch_local_reverse_normal = []
      if self.limit_switch_remote_forward_source is None:
        self.limit_switch_remote_forward_source = []
      if self.limit_switch_remote_forward_normal is None:
        self.limit_switch_remote_forward_normal = []
      if self.limit_switch_remote_forward_id is None:
        self.limit_switch_remote_forward_id = b''
      if self.limit_switch_remote_reverse_source is None:
        self.limit_switch_remote_reverse_source = []
      if self.limit_switch_remote_reverse_normal is None:
        self.limit_switch_remote_reverse_normal = []
      if self.limit_switch_remote_reverse_id is None:
        self.limit_switch_remote_reverse_id = b''
      if self.softlimit_forward_threshold is None:
        self.softlimit_forward_threshold = []
      if self.softlimit_forward_enable is None:
        self.softlimit_forward_enable = []
      if self.softlimit_reverse_threshold is None:
        self.softlimit_reverse_threshold = []
      if self.softlimit_reverse_enable is None:
        self.softlimit_reverse_enable = []
      if self.softlimits_override_enable is None:
        self.softlimits_override_enable = []
      if self.current_limit_peak_amps is None:
        self.current_limit_peak_amps = []
      if self.current_limit_peak_msec is None:
        self.current_limit_peak_msec = []
      if self.current_limit_continuous_amps is None:
        self.current_limit_continuous_amps = []
      if self.current_limit_enable is None:
        self.current_limit_enable = []
      if self.motion_cruise_velocity is None:
        self.motion_cruise_velocity = []
      if self.motion_acceleration is None:
        self.motion_acceleration = []
      if self.motion_s_curve_strength is None:
        self.motion_s_curve_strength = b''
      if self.status_1_general_period is None:
        self.status_1_general_period = b''
      if self.status_2_feedback0_period is None:
        self.status_2_feedback0_period = b''
      if self.status_3_quadrature_period is None:
        self.status_3_quadrature_period = b''
      if self.status_4_aintempvbat_period is None:
        self.status_4_aintempvbat_period = b''
      if self.status_6_misc_period is None:
        self.status_6_misc_period = b''
      if self.status_7_commstatus_period is None:
        self.status_7_commstatus_period = b''
      if self.status_8_pulsewidth_period is None:
        self.status_8_pulsewidth_period = b''
      if self.status_9_motprofbuffer_period is None:
        self.status_9_motprofbuffer_period = b''
      if self.status_10_motionmagic_period is None:
        self.status_10_motionmagic_period = b''
      if self.status_11_uartgadgeteer_period is None:
        self.status_11_uartgadgeteer_period = b''
      if self.status_12_feedback1_period is None:
        self.status_12_feedback1_period = b''
      if self.status_13_base_pidf0_period is None:
        self.status_13_base_pidf0_period = b''
      if self.status_14_turn_pidf1_period is None:
        self.status_14_turn_pidf1_period = b''
      if self.status_15_firmwareapistatus_period is None:
        self.status_15_firmwareapistatus_period = b''
      if self.control_3_general_period is None:
        self.control_3_general_period = b''
      if self.control_4_advanced_period is None:
        self.control_4_advanced_period = b''
      if self.control_5_feedbackoutputoverride_period is None:
        self.control_5_feedbackoutputoverride_period = b''
      if self.control_6_motprofaddtrajpoint_period is None:
        self.control_6_motprofaddtrajpoint_period = b''
      if self.motion_profile_trajectory_period is None:
        self.motion_profile_trajectory_period = []
      if self.conversion_factor is None:
        self.conversion_factor = []
      if self.firmware_version is None:
        self.firmware_version = []
      if self.water_game is None:
        self.water_game = []
    else:
      self.header = std_msgs.msg.Header()
      self.name = []
      self.can_id = []
      self.feedback_coefficient = []
      self.feedback_sensor = []
      self.remote_feedback_sensor = []
      self.remote_feedback_device_id0 = []
      self.remote_feedback_filter0 = []
      self.remote_feedback_device_id1 = []
      self.remote_feedback_filter1 = []
      self.sensor_term_sum0 = []
      self.sensor_term_sum1 = []
      self.sensor_term_diff0 = []
      self.sensor_term_diff1 = []
      self.encoder_ticks_per_rotation = []
      self.pid_slot = []
      self.pid_p0 = []
      self.pid_i0 = []
      self.pid_d0 = []
      self.pid_f0 = []
      self.pid_izone0 = []
      self.pid_allowable_closed_loop_error0 = []
      self.pid_max_integral_accumulator0 = []
      self.pid_closed_loop_peak_output0 = []
      self.pid_closed_loop_period0 = []
      self.pid_p1 = []
      self.pid_i1 = []
      self.pid_d1 = []
      self.pid_f1 = []
      self.pid_izone1 = []
      self.pid_allowable_closed_loop_error1 = []
      self.pid_max_integral_accumulator1 = []
      self.pid_closed_loop_peak_output1 = []
      self.pid_closed_loop_period1 = []
      self.pid_p2 = []
      self.pid_i2 = []
      self.pid_d2 = []
      self.pid_f2 = []
      self.pid_izone2 = []
      self.pid_allowable_closed_loop_error2 = []
      self.pid_max_integral_accumulator2 = []
      self.pid_closed_loop_peak_output2 = []
      self.pid_closed_loop_period2 = []
      self.pid_p3 = []
      self.pid_i3 = []
      self.pid_d3 = []
      self.pid_f3 = []
      self.pid_izone3 = []
      self.pid_allowable_closed_loop_error3 = []
      self.pid_max_integral_accumulator3 = []
      self.pid_closed_loop_peak_output3 = []
      self.pid_closed_loop_period3 = []
      self.aux_pid_polarity = []
      self.invert = []
      self.sensorPhase = []
      self.neutral_mode = []
      self.closed_loop_ramp = []
      self.open_loop_ramp = []
      self.peak_output_forward = []
      self.peak_output_reverse = []
      self.nominal_output_forward = []
      self.nominal_output_reverse = []
      self.neutral_deadband = []
      self.voltage_compensation_saturation = []
      self.voltage_measurement_filter = []
      self.voltage_compensation_enable = []
      self.velocity_measurement_period = []
      self.velocity_measurement_window = []
      self.limit_switch_local_forward_source = []
      self.limit_switch_local_forward_normal = []
      self.limit_switch_local_reverse_source = []
      self.limit_switch_local_reverse_normal = []
      self.limit_switch_remote_forward_source = []
      self.limit_switch_remote_forward_normal = []
      self.limit_switch_remote_forward_id = b''
      self.limit_switch_remote_reverse_source = []
      self.limit_switch_remote_reverse_normal = []
      self.limit_switch_remote_reverse_id = b''
      self.softlimit_forward_threshold = []
      self.softlimit_forward_enable = []
      self.softlimit_reverse_threshold = []
      self.softlimit_reverse_enable = []
      self.softlimits_override_enable = []
      self.current_limit_peak_amps = []
      self.current_limit_peak_msec = []
      self.current_limit_continuous_amps = []
      self.current_limit_enable = []
      self.motion_cruise_velocity = []
      self.motion_acceleration = []
      self.motion_s_curve_strength = b''
      self.status_1_general_period = b''
      self.status_2_feedback0_period = b''
      self.status_3_quadrature_period = b''
      self.status_4_aintempvbat_period = b''
      self.status_6_misc_period = b''
      self.status_7_commstatus_period = b''
      self.status_8_pulsewidth_period = b''
      self.status_9_motprofbuffer_period = b''
      self.status_10_motionmagic_period = b''
      self.status_11_uartgadgeteer_period = b''
      self.status_12_feedback1_period = b''
      self.status_13_base_pidf0_period = b''
      self.status_14_turn_pidf1_period = b''
      self.status_15_firmwareapistatus_period = b''
      self.control_3_general_period = b''
      self.control_4_advanced_period = b''
      self.control_5_feedbackoutputoverride_period = b''
      self.control_6_motprofaddtrajpoint_period = b''
      self.motion_profile_trajectory_period = []
      self.conversion_factor = []
      self.firmware_version = []
      self.water_game = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.can_id)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(struct.pack(pattern, *self.can_id))
      length = len(self.feedback_coefficient)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.feedback_coefficient))
      length = len(self.feedback_sensor)
      buff.write(_struct_I.pack(length))
      for val1 in self.feedback_sensor:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_sensor)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_sensor:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_device_id0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(struct.pack(pattern, *self.remote_feedback_device_id0))
      length = len(self.remote_feedback_filter0)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_filter0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_device_id1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(struct.pack(pattern, *self.remote_feedback_device_id1))
      length = len(self.remote_feedback_filter1)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_filter1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_sum0)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_sum0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_sum1)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_sum1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_diff0)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_diff0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_diff1)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_diff1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.encoder_ticks_per_rotation)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.encoder_ticks_per_rotation))
      length = len(self.pid_slot)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_slot))
      length = len(self.pid_p0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_p0))
      length = len(self.pid_i0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_i0))
      length = len(self.pid_d0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_d0))
      length = len(self.pid_f0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_f0))
      length = len(self.pid_izone0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_izone0))
      length = len(self.pid_allowable_closed_loop_error0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_allowable_closed_loop_error0))
      length = len(self.pid_max_integral_accumulator0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_max_integral_accumulator0))
      length = len(self.pid_closed_loop_peak_output0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_peak_output0))
      length = len(self.pid_closed_loop_period0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_period0))
      length = len(self.pid_p1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_p1))
      length = len(self.pid_i1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_i1))
      length = len(self.pid_d1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_d1))
      length = len(self.pid_f1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_f1))
      length = len(self.pid_izone1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_izone1))
      length = len(self.pid_allowable_closed_loop_error1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_allowable_closed_loop_error1))
      length = len(self.pid_max_integral_accumulator1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_max_integral_accumulator1))
      length = len(self.pid_closed_loop_peak_output1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_peak_output1))
      length = len(self.pid_closed_loop_period1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_period1))
      length = len(self.pid_p2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_p2))
      length = len(self.pid_i2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_i2))
      length = len(self.pid_d2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_d2))
      length = len(self.pid_f2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_f2))
      length = len(self.pid_izone2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_izone2))
      length = len(self.pid_allowable_closed_loop_error2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_allowable_closed_loop_error2))
      length = len(self.pid_max_integral_accumulator2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_max_integral_accumulator2))
      length = len(self.pid_closed_loop_peak_output2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_peak_output2))
      length = len(self.pid_closed_loop_period2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_period2))
      length = len(self.pid_p3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_p3))
      length = len(self.pid_i3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_i3))
      length = len(self.pid_d3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_d3))
      length = len(self.pid_f3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_f3))
      length = len(self.pid_izone3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_izone3))
      length = len(self.pid_allowable_closed_loop_error3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_allowable_closed_loop_error3))
      length = len(self.pid_max_integral_accumulator3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_max_integral_accumulator3))
      length = len(self.pid_closed_loop_peak_output3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_peak_output3))
      length = len(self.pid_closed_loop_period3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.pid_closed_loop_period3))
      length = len(self.aux_pid_polarity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.aux_pid_polarity))
      length = len(self.invert)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.invert))
      length = len(self.sensorPhase)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.sensorPhase))
      length = len(self.neutral_mode)
      buff.write(_struct_I.pack(length))
      for val1 in self.neutral_mode:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.closed_loop_ramp)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.closed_loop_ramp))
      length = len(self.open_loop_ramp)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.open_loop_ramp))
      length = len(self.peak_output_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.peak_output_forward))
      length = len(self.peak_output_reverse)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.peak_output_reverse))
      length = len(self.nominal_output_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.nominal_output_forward))
      length = len(self.nominal_output_reverse)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.nominal_output_reverse))
      length = len(self.neutral_deadband)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.neutral_deadband))
      length = len(self.voltage_compensation_saturation)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.voltage_compensation_saturation))
      length = len(self.voltage_measurement_filter)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.voltage_measurement_filter))
      length = len(self.voltage_compensation_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.voltage_compensation_enable))
      length = len(self.velocity_measurement_period)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.velocity_measurement_period))
      length = len(self.velocity_measurement_window)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.velocity_measurement_window))
      length = len(self.limit_switch_local_forward_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_forward_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_forward_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_forward_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_reverse_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_reverse_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_reverse_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_reverse_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_forward_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_forward_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_forward_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_forward_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      _x = self.limit_switch_remote_forward_id
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.limit_switch_remote_reverse_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_reverse_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_reverse_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_reverse_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      _x = self.limit_switch_remote_reverse_id
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.softlimit_forward_threshold)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.softlimit_forward_threshold))
      length = len(self.softlimit_forward_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.softlimit_forward_enable))
      length = len(self.softlimit_reverse_threshold)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.softlimit_reverse_threshold))
      length = len(self.softlimit_reverse_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.softlimit_reverse_enable))
      length = len(self.softlimits_override_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.softlimits_override_enable))
      length = len(self.current_limit_peak_amps)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.current_limit_peak_amps))
      length = len(self.current_limit_peak_msec)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.current_limit_peak_msec))
      length = len(self.current_limit_continuous_amps)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.current_limit_continuous_amps))
      length = len(self.current_limit_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.current_limit_enable))
      length = len(self.motion_cruise_velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.motion_cruise_velocity))
      length = len(self.motion_acceleration)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.motion_acceleration))
      _x = self.motion_s_curve_strength
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_1_general_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_2_feedback0_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_3_quadrature_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_4_aintempvbat_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_6_misc_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_7_commstatus_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_8_pulsewidth_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_9_motprofbuffer_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_10_motionmagic_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_11_uartgadgeteer_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_12_feedback1_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_13_base_pidf0_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_14_turn_pidf1_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_15_firmwareapistatus_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_3_general_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_4_advanced_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_5_feedbackoutputoverride_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_6_motprofaddtrajpoint_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.motion_profile_trajectory_period)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.motion_profile_trajectory_period))
      length = len(self.conversion_factor)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.conversion_factor))
      length = len(self.firmware_version)
      buff.write(_struct_I.pack(length))
      for val1 in self.firmware_version:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.water_game)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.water_game))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.can_id = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.feedback_coefficient = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.feedback_sensor = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.feedback_sensor.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_sensor = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_sensor.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.remote_feedback_device_id0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_filter0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_filter0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.remote_feedback_device_id1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_filter1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_filter1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_sum0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_sum0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_sum1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_sum1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_diff0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_diff0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_diff1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_diff1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.encoder_ticks_per_rotation = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_slot = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period2 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period3 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.aux_pid_polarity = struct.unpack(pattern, str[start:end])
      self.aux_pid_polarity = list(map(bool, self.aux_pid_polarity))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.invert = struct.unpack(pattern, str[start:end])
      self.invert = list(map(bool, self.invert))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensorPhase = struct.unpack(pattern, str[start:end])
      self.sensorPhase = list(map(bool, self.sensorPhase))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.neutral_mode = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.neutral_mode.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_ramp = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.open_loop_ramp = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.peak_output_forward = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.peak_output_reverse = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.nominal_output_forward = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.nominal_output_reverse = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.neutral_deadband = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_compensation_saturation = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_measurement_filter = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_compensation_enable = struct.unpack(pattern, str[start:end])
      self.voltage_compensation_enable = list(map(bool, self.voltage_compensation_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.velocity_measurement_period = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.velocity_measurement_window = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_forward_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_forward_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_forward_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_forward_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_reverse_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_reverse_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_reverse_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_reverse_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_forward_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_forward_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_forward_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_forward_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.limit_switch_remote_forward_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_reverse_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_reverse_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_reverse_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_reverse_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.limit_switch_remote_reverse_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_forward_threshold = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_forward_enable = struct.unpack(pattern, str[start:end])
      self.softlimit_forward_enable = list(map(bool, self.softlimit_forward_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_reverse_threshold = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_reverse_enable = struct.unpack(pattern, str[start:end])
      self.softlimit_reverse_enable = list(map(bool, self.softlimit_reverse_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimits_override_enable = struct.unpack(pattern, str[start:end])
      self.softlimits_override_enable = list(map(bool, self.softlimits_override_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_peak_amps = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_peak_msec = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_continuous_amps = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_enable = struct.unpack(pattern, str[start:end])
      self.current_limit_enable = list(map(bool, self.current_limit_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_cruise_velocity = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_acceleration = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.motion_s_curve_strength = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_1_general_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_2_feedback0_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_3_quadrature_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_4_aintempvbat_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_6_misc_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_7_commstatus_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_8_pulsewidth_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_9_motprofbuffer_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_10_motionmagic_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_11_uartgadgeteer_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_12_feedback1_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_13_base_pidf0_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_14_turn_pidf1_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_15_firmwareapistatus_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_3_general_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_4_advanced_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_5_feedbackoutputoverride_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_6_motprofaddtrajpoint_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_trajectory_period = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.conversion_factor = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.firmware_version = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.firmware_version.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.water_game = struct.unpack(pattern, str[start:end])
      self.water_game = list(map(bool, self.water_game))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.can_id)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(self.can_id.tostring())
      length = len(self.feedback_coefficient)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.feedback_coefficient.tostring())
      length = len(self.feedback_sensor)
      buff.write(_struct_I.pack(length))
      for val1 in self.feedback_sensor:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_sensor)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_sensor:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_device_id0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(self.remote_feedback_device_id0.tostring())
      length = len(self.remote_feedback_filter0)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_filter0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.remote_feedback_device_id1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(self.remote_feedback_device_id1.tostring())
      length = len(self.remote_feedback_filter1)
      buff.write(_struct_I.pack(length))
      for val1 in self.remote_feedback_filter1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_sum0)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_sum0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_sum1)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_sum1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_diff0)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_diff0:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sensor_term_diff1)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensor_term_diff1:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.encoder_ticks_per_rotation)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.encoder_ticks_per_rotation.tostring())
      length = len(self.pid_slot)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_slot.tostring())
      length = len(self.pid_p0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_p0.tostring())
      length = len(self.pid_i0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_i0.tostring())
      length = len(self.pid_d0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_d0.tostring())
      length = len(self.pid_f0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_f0.tostring())
      length = len(self.pid_izone0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_izone0.tostring())
      length = len(self.pid_allowable_closed_loop_error0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_allowable_closed_loop_error0.tostring())
      length = len(self.pid_max_integral_accumulator0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_max_integral_accumulator0.tostring())
      length = len(self.pid_closed_loop_peak_output0)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_closed_loop_peak_output0.tostring())
      length = len(self.pid_closed_loop_period0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_closed_loop_period0.tostring())
      length = len(self.pid_p1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_p1.tostring())
      length = len(self.pid_i1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_i1.tostring())
      length = len(self.pid_d1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_d1.tostring())
      length = len(self.pid_f1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_f1.tostring())
      length = len(self.pid_izone1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_izone1.tostring())
      length = len(self.pid_allowable_closed_loop_error1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_allowable_closed_loop_error1.tostring())
      length = len(self.pid_max_integral_accumulator1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_max_integral_accumulator1.tostring())
      length = len(self.pid_closed_loop_peak_output1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_closed_loop_peak_output1.tostring())
      length = len(self.pid_closed_loop_period1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_closed_loop_period1.tostring())
      length = len(self.pid_p2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_p2.tostring())
      length = len(self.pid_i2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_i2.tostring())
      length = len(self.pid_d2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_d2.tostring())
      length = len(self.pid_f2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_f2.tostring())
      length = len(self.pid_izone2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_izone2.tostring())
      length = len(self.pid_allowable_closed_loop_error2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_allowable_closed_loop_error2.tostring())
      length = len(self.pid_max_integral_accumulator2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_max_integral_accumulator2.tostring())
      length = len(self.pid_closed_loop_peak_output2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_closed_loop_peak_output2.tostring())
      length = len(self.pid_closed_loop_period2)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_closed_loop_period2.tostring())
      length = len(self.pid_p3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_p3.tostring())
      length = len(self.pid_i3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_i3.tostring())
      length = len(self.pid_d3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_d3.tostring())
      length = len(self.pid_f3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_f3.tostring())
      length = len(self.pid_izone3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_izone3.tostring())
      length = len(self.pid_allowable_closed_loop_error3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_allowable_closed_loop_error3.tostring())
      length = len(self.pid_max_integral_accumulator3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_max_integral_accumulator3.tostring())
      length = len(self.pid_closed_loop_peak_output3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.pid_closed_loop_peak_output3.tostring())
      length = len(self.pid_closed_loop_period3)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pid_closed_loop_period3.tostring())
      length = len(self.aux_pid_polarity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.aux_pid_polarity.tostring())
      length = len(self.invert)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.invert.tostring())
      length = len(self.sensorPhase)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.sensorPhase.tostring())
      length = len(self.neutral_mode)
      buff.write(_struct_I.pack(length))
      for val1 in self.neutral_mode:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.closed_loop_ramp)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.closed_loop_ramp.tostring())
      length = len(self.open_loop_ramp)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.open_loop_ramp.tostring())
      length = len(self.peak_output_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.peak_output_forward.tostring())
      length = len(self.peak_output_reverse)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.peak_output_reverse.tostring())
      length = len(self.nominal_output_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.nominal_output_forward.tostring())
      length = len(self.nominal_output_reverse)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.nominal_output_reverse.tostring())
      length = len(self.neutral_deadband)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.neutral_deadband.tostring())
      length = len(self.voltage_compensation_saturation)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.voltage_compensation_saturation.tostring())
      length = len(self.voltage_measurement_filter)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.voltage_measurement_filter.tostring())
      length = len(self.voltage_compensation_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.voltage_compensation_enable.tostring())
      length = len(self.velocity_measurement_period)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.velocity_measurement_period.tostring())
      length = len(self.velocity_measurement_window)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.velocity_measurement_window.tostring())
      length = len(self.limit_switch_local_forward_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_forward_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_forward_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_forward_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_reverse_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_reverse_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_local_reverse_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_local_reverse_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_forward_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_forward_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_forward_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_forward_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      _x = self.limit_switch_remote_forward_id
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.limit_switch_remote_reverse_source)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_reverse_source:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.limit_switch_remote_reverse_normal)
      buff.write(_struct_I.pack(length))
      for val1 in self.limit_switch_remote_reverse_normal:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      _x = self.limit_switch_remote_reverse_id
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.softlimit_forward_threshold)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.softlimit_forward_threshold.tostring())
      length = len(self.softlimit_forward_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.softlimit_forward_enable.tostring())
      length = len(self.softlimit_reverse_threshold)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.softlimit_reverse_threshold.tostring())
      length = len(self.softlimit_reverse_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.softlimit_reverse_enable.tostring())
      length = len(self.softlimits_override_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.softlimits_override_enable.tostring())
      length = len(self.current_limit_peak_amps)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.current_limit_peak_amps.tostring())
      length = len(self.current_limit_peak_msec)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.current_limit_peak_msec.tostring())
      length = len(self.current_limit_continuous_amps)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.current_limit_continuous_amps.tostring())
      length = len(self.current_limit_enable)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.current_limit_enable.tostring())
      length = len(self.motion_cruise_velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.motion_cruise_velocity.tostring())
      length = len(self.motion_acceleration)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.motion_acceleration.tostring())
      _x = self.motion_s_curve_strength
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_1_general_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_2_feedback0_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_3_quadrature_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_4_aintempvbat_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_6_misc_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_7_commstatus_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_8_pulsewidth_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_9_motprofbuffer_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_10_motionmagic_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_11_uartgadgeteer_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_12_feedback1_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_13_base_pidf0_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_14_turn_pidf1_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.status_15_firmwareapistatus_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_3_general_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_4_advanced_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_5_feedbackoutputoverride_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.control_6_motprofaddtrajpoint_period
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.motion_profile_trajectory_period)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.motion_profile_trajectory_period.tostring())
      length = len(self.conversion_factor)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.conversion_factor.tostring())
      length = len(self.firmware_version)
      buff.write(_struct_I.pack(length))
      for val1 in self.firmware_version:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.water_game)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.water_game.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.can_id = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.feedback_coefficient = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.feedback_sensor = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.feedback_sensor.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_sensor = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_sensor.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.remote_feedback_device_id0 = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_filter0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_filter0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      end += struct.calcsize(pattern)
      self.remote_feedback_device_id1 = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remote_feedback_filter1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.remote_feedback_filter1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_sum0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_sum0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_sum1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_sum1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_diff0 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_diff0.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensor_term_diff1 = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sensor_term_diff1.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.encoder_ticks_per_rotation = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_slot = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone0 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error0 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output0 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period0 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone1 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error1 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output1 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period1 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone2 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error2 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output2 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period2 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_p3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_i3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_d3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_f3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_izone3 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_allowable_closed_loop_error3 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_max_integral_accumulator3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_peak_output3 = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.pid_closed_loop_period3 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.aux_pid_polarity = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.aux_pid_polarity = list(map(bool, self.aux_pid_polarity))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.invert = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.invert = list(map(bool, self.invert))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.sensorPhase = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.sensorPhase = list(map(bool, self.sensorPhase))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.neutral_mode = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.neutral_mode.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_ramp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.open_loop_ramp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.peak_output_forward = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.peak_output_reverse = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.nominal_output_forward = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.nominal_output_reverse = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.neutral_deadband = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_compensation_saturation = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_measurement_filter = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.voltage_compensation_enable = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.voltage_compensation_enable = list(map(bool, self.voltage_compensation_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.velocity_measurement_period = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.velocity_measurement_window = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_forward_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_forward_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_forward_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_forward_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_reverse_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_reverse_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_local_reverse_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_local_reverse_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_forward_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_forward_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_forward_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_forward_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.limit_switch_remote_forward_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_reverse_source = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_reverse_source.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.limit_switch_remote_reverse_normal = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.limit_switch_remote_reverse_normal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.limit_switch_remote_reverse_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_forward_threshold = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_forward_enable = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.softlimit_forward_enable = list(map(bool, self.softlimit_forward_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_reverse_threshold = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimit_reverse_enable = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.softlimit_reverse_enable = list(map(bool, self.softlimit_reverse_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.softlimits_override_enable = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.softlimits_override_enable = list(map(bool, self.softlimits_override_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_peak_amps = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_peak_msec = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_continuous_amps = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.current_limit_enable = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.current_limit_enable = list(map(bool, self.current_limit_enable))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_cruise_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_acceleration = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.motion_s_curve_strength = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_1_general_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_2_feedback0_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_3_quadrature_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_4_aintempvbat_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_6_misc_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_7_commstatus_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_8_pulsewidth_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_9_motprofbuffer_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_10_motionmagic_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_11_uartgadgeteer_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_12_feedback1_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_13_base_pidf0_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_14_turn_pidf1_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status_15_firmwareapistatus_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_3_general_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_4_advanced_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_5_feedbackoutputoverride_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.control_6_motprofaddtrajpoint_period = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_trajectory_period = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.conversion_factor = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.firmware_version = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.firmware_version.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.water_game = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.water_game = list(map(bool, self.water_game))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
