# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from talon_state_msgs/TalonState.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg
import talon_state_msgs.msg

class TalonState(genpy.Message):
  _md5sum = "3c4ea359830a4aa13b177949e57ebce3"
  _type = "talon_state_msgs/TalonState"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header

string[] name
string[] talon_mode
string[] demand1_type
float64[] demand1_value
float64[] position
float64[] speed
float64[] output_voltage
float64[] output_current
float64[] bus_voltage
float64[] motor_output_percent
float64[] temperature
float64[] set_point
float64[] closed_loop_error
float64[] integral_accumulator
float64[] error_derivative
float64[] closed_loop_target
float64[] p_term
float64[] i_term
float64[] d_term
float64[] f_term
float64[] active_trajectory_position
float64[] active_trajectory_velocity
float64[] active_trajectory_arbitrary_feed_forward
float64[] active_trajectory_heading
bool[] forward_limit_switch
bool[] reverse_limit_switch
bool[] forward_softlimit
bool[] reverse_softlimit
bool[] neutral_output
int32[]   motion_profile_top_level_buffer_count
bool[]    motion_profile_top_level_buffer_full
int32[]   motion_profile_status_top_buffer_rem
int32[]   motion_profile_status_top_buffer_cnt
int32[]   motion_profile_status_btm_buffer_cnt
bool[]    motion_profile_status_has_underrun
bool[]    motion_profile_status_is_underrun
bool[]    motion_profile_status_active_point_valid
bool[]    motion_profile_status_is_last
int32[]   motion_profile_status_profile_slot_select0
int32[]   motion_profile_status_profile_slot_select1
string[]  motion_profile_status_output_enable
int32[]   motion_profile_time_dur_ms
string[]  faults
string[]  sticky_faults
float64[] conversion_factor
talon_state_msgs/CustomProfileStatus[] custom_profile_status

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: talon_state_msgs/CustomProfileStatus
bool running
int32 slotRunning
int32[] remainingPoints
float64 remainingTime
bool outOfPoints
"""
  __slots__ = ['header','name','talon_mode','demand1_type','demand1_value','position','speed','output_voltage','output_current','bus_voltage','motor_output_percent','temperature','set_point','closed_loop_error','integral_accumulator','error_derivative','closed_loop_target','p_term','i_term','d_term','f_term','active_trajectory_position','active_trajectory_velocity','active_trajectory_arbitrary_feed_forward','active_trajectory_heading','forward_limit_switch','reverse_limit_switch','forward_softlimit','reverse_softlimit','neutral_output','motion_profile_top_level_buffer_count','motion_profile_top_level_buffer_full','motion_profile_status_top_buffer_rem','motion_profile_status_top_buffer_cnt','motion_profile_status_btm_buffer_cnt','motion_profile_status_has_underrun','motion_profile_status_is_underrun','motion_profile_status_active_point_valid','motion_profile_status_is_last','motion_profile_status_profile_slot_select0','motion_profile_status_profile_slot_select1','motion_profile_status_output_enable','motion_profile_time_dur_ms','faults','sticky_faults','conversion_factor','custom_profile_status']
  _slot_types = ['std_msgs/Header','string[]','string[]','string[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','float64[]','bool[]','bool[]','bool[]','bool[]','bool[]','int32[]','bool[]','int32[]','int32[]','int32[]','bool[]','bool[]','bool[]','bool[]','int32[]','int32[]','string[]','int32[]','string[]','string[]','float64[]','talon_state_msgs/CustomProfileStatus[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,name,talon_mode,demand1_type,demand1_value,position,speed,output_voltage,output_current,bus_voltage,motor_output_percent,temperature,set_point,closed_loop_error,integral_accumulator,error_derivative,closed_loop_target,p_term,i_term,d_term,f_term,active_trajectory_position,active_trajectory_velocity,active_trajectory_arbitrary_feed_forward,active_trajectory_heading,forward_limit_switch,reverse_limit_switch,forward_softlimit,reverse_softlimit,neutral_output,motion_profile_top_level_buffer_count,motion_profile_top_level_buffer_full,motion_profile_status_top_buffer_rem,motion_profile_status_top_buffer_cnt,motion_profile_status_btm_buffer_cnt,motion_profile_status_has_underrun,motion_profile_status_is_underrun,motion_profile_status_active_point_valid,motion_profile_status_is_last,motion_profile_status_profile_slot_select0,motion_profile_status_profile_slot_select1,motion_profile_status_output_enable,motion_profile_time_dur_ms,faults,sticky_faults,conversion_factor,custom_profile_status

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(TalonState, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.name is None:
        self.name = []
      if self.talon_mode is None:
        self.talon_mode = []
      if self.demand1_type is None:
        self.demand1_type = []
      if self.demand1_value is None:
        self.demand1_value = []
      if self.position is None:
        self.position = []
      if self.speed is None:
        self.speed = []
      if self.output_voltage is None:
        self.output_voltage = []
      if self.output_current is None:
        self.output_current = []
      if self.bus_voltage is None:
        self.bus_voltage = []
      if self.motor_output_percent is None:
        self.motor_output_percent = []
      if self.temperature is None:
        self.temperature = []
      if self.set_point is None:
        self.set_point = []
      if self.closed_loop_error is None:
        self.closed_loop_error = []
      if self.integral_accumulator is None:
        self.integral_accumulator = []
      if self.error_derivative is None:
        self.error_derivative = []
      if self.closed_loop_target is None:
        self.closed_loop_target = []
      if self.p_term is None:
        self.p_term = []
      if self.i_term is None:
        self.i_term = []
      if self.d_term is None:
        self.d_term = []
      if self.f_term is None:
        self.f_term = []
      if self.active_trajectory_position is None:
        self.active_trajectory_position = []
      if self.active_trajectory_velocity is None:
        self.active_trajectory_velocity = []
      if self.active_trajectory_arbitrary_feed_forward is None:
        self.active_trajectory_arbitrary_feed_forward = []
      if self.active_trajectory_heading is None:
        self.active_trajectory_heading = []
      if self.forward_limit_switch is None:
        self.forward_limit_switch = []
      if self.reverse_limit_switch is None:
        self.reverse_limit_switch = []
      if self.forward_softlimit is None:
        self.forward_softlimit = []
      if self.reverse_softlimit is None:
        self.reverse_softlimit = []
      if self.neutral_output is None:
        self.neutral_output = []
      if self.motion_profile_top_level_buffer_count is None:
        self.motion_profile_top_level_buffer_count = []
      if self.motion_profile_top_level_buffer_full is None:
        self.motion_profile_top_level_buffer_full = []
      if self.motion_profile_status_top_buffer_rem is None:
        self.motion_profile_status_top_buffer_rem = []
      if self.motion_profile_status_top_buffer_cnt is None:
        self.motion_profile_status_top_buffer_cnt = []
      if self.motion_profile_status_btm_buffer_cnt is None:
        self.motion_profile_status_btm_buffer_cnt = []
      if self.motion_profile_status_has_underrun is None:
        self.motion_profile_status_has_underrun = []
      if self.motion_profile_status_is_underrun is None:
        self.motion_profile_status_is_underrun = []
      if self.motion_profile_status_active_point_valid is None:
        self.motion_profile_status_active_point_valid = []
      if self.motion_profile_status_is_last is None:
        self.motion_profile_status_is_last = []
      if self.motion_profile_status_profile_slot_select0 is None:
        self.motion_profile_status_profile_slot_select0 = []
      if self.motion_profile_status_profile_slot_select1 is None:
        self.motion_profile_status_profile_slot_select1 = []
      if self.motion_profile_status_output_enable is None:
        self.motion_profile_status_output_enable = []
      if self.motion_profile_time_dur_ms is None:
        self.motion_profile_time_dur_ms = []
      if self.faults is None:
        self.faults = []
      if self.sticky_faults is None:
        self.sticky_faults = []
      if self.conversion_factor is None:
        self.conversion_factor = []
      if self.custom_profile_status is None:
        self.custom_profile_status = []
    else:
      self.header = std_msgs.msg.Header()
      self.name = []
      self.talon_mode = []
      self.demand1_type = []
      self.demand1_value = []
      self.position = []
      self.speed = []
      self.output_voltage = []
      self.output_current = []
      self.bus_voltage = []
      self.motor_output_percent = []
      self.temperature = []
      self.set_point = []
      self.closed_loop_error = []
      self.integral_accumulator = []
      self.error_derivative = []
      self.closed_loop_target = []
      self.p_term = []
      self.i_term = []
      self.d_term = []
      self.f_term = []
      self.active_trajectory_position = []
      self.active_trajectory_velocity = []
      self.active_trajectory_arbitrary_feed_forward = []
      self.active_trajectory_heading = []
      self.forward_limit_switch = []
      self.reverse_limit_switch = []
      self.forward_softlimit = []
      self.reverse_softlimit = []
      self.neutral_output = []
      self.motion_profile_top_level_buffer_count = []
      self.motion_profile_top_level_buffer_full = []
      self.motion_profile_status_top_buffer_rem = []
      self.motion_profile_status_top_buffer_cnt = []
      self.motion_profile_status_btm_buffer_cnt = []
      self.motion_profile_status_has_underrun = []
      self.motion_profile_status_is_underrun = []
      self.motion_profile_status_active_point_valid = []
      self.motion_profile_status_is_last = []
      self.motion_profile_status_profile_slot_select0 = []
      self.motion_profile_status_profile_slot_select1 = []
      self.motion_profile_status_output_enable = []
      self.motion_profile_time_dur_ms = []
      self.faults = []
      self.sticky_faults = []
      self.conversion_factor = []
      self.custom_profile_status = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.talon_mode)
      buff.write(_struct_I.pack(length))
      for val1 in self.talon_mode:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.demand1_type)
      buff.write(_struct_I.pack(length))
      for val1 in self.demand1_type:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.demand1_value)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.demand1_value))
      length = len(self.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.position))
      length = len(self.speed)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.speed))
      length = len(self.output_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.output_voltage))
      length = len(self.output_current)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.output_current))
      length = len(self.bus_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.bus_voltage))
      length = len(self.motor_output_percent)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.motor_output_percent))
      length = len(self.temperature)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.temperature))
      length = len(self.set_point)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.set_point))
      length = len(self.closed_loop_error)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.closed_loop_error))
      length = len(self.integral_accumulator)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.integral_accumulator))
      length = len(self.error_derivative)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.error_derivative))
      length = len(self.closed_loop_target)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.closed_loop_target))
      length = len(self.p_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.p_term))
      length = len(self.i_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.i_term))
      length = len(self.d_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.d_term))
      length = len(self.f_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.f_term))
      length = len(self.active_trajectory_position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.active_trajectory_position))
      length = len(self.active_trajectory_velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.active_trajectory_velocity))
      length = len(self.active_trajectory_arbitrary_feed_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.active_trajectory_arbitrary_feed_forward))
      length = len(self.active_trajectory_heading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.active_trajectory_heading))
      length = len(self.forward_limit_switch)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.forward_limit_switch))
      length = len(self.reverse_limit_switch)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.reverse_limit_switch))
      length = len(self.forward_softlimit)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.forward_softlimit))
      length = len(self.reverse_softlimit)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.reverse_softlimit))
      length = len(self.neutral_output)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.neutral_output))
      length = len(self.motion_profile_top_level_buffer_count)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_top_level_buffer_count))
      length = len(self.motion_profile_top_level_buffer_full)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.motion_profile_top_level_buffer_full))
      length = len(self.motion_profile_status_top_buffer_rem)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_top_buffer_rem))
      length = len(self.motion_profile_status_top_buffer_cnt)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_top_buffer_cnt))
      length = len(self.motion_profile_status_btm_buffer_cnt)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_btm_buffer_cnt))
      length = len(self.motion_profile_status_has_underrun)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_has_underrun))
      length = len(self.motion_profile_status_is_underrun)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_is_underrun))
      length = len(self.motion_profile_status_active_point_valid)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_active_point_valid))
      length = len(self.motion_profile_status_is_last)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_is_last))
      length = len(self.motion_profile_status_profile_slot_select0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_profile_slot_select0))
      length = len(self.motion_profile_status_profile_slot_select1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_status_profile_slot_select1))
      length = len(self.motion_profile_status_output_enable)
      buff.write(_struct_I.pack(length))
      for val1 in self.motion_profile_status_output_enable:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.motion_profile_time_dur_ms)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.motion_profile_time_dur_ms))
      length = len(self.faults)
      buff.write(_struct_I.pack(length))
      for val1 in self.faults:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sticky_faults)
      buff.write(_struct_I.pack(length))
      for val1 in self.sticky_faults:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.conversion_factor)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.conversion_factor))
      length = len(self.custom_profile_status)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_profile_status:
        _x = val1
        buff.write(_get_struct_Bi().pack(_x.running, _x.slotRunning))
        length = len(val1.remainingPoints)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.pack(pattern, *val1.remainingPoints))
        _x = val1
        buff.write(_get_struct_dB().pack(_x.remainingTime, _x.outOfPoints))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.custom_profile_status is None:
        self.custom_profile_status = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.talon_mode = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.talon_mode.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.demand1_type = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.demand1_type.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.demand1_value = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.position = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.speed = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.output_voltage = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.output_current = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.bus_voltage = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motor_output_percent = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.temperature = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.set_point = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_error = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.integral_accumulator = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.error_derivative = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_target = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.p_term = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.i_term = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.d_term = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.f_term = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_position = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_velocity = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_arbitrary_feed_forward = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_heading = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.forward_limit_switch = struct.unpack(pattern, str[start:end])
      self.forward_limit_switch = list(map(bool, self.forward_limit_switch))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.reverse_limit_switch = struct.unpack(pattern, str[start:end])
      self.reverse_limit_switch = list(map(bool, self.reverse_limit_switch))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.forward_softlimit = struct.unpack(pattern, str[start:end])
      self.forward_softlimit = list(map(bool, self.forward_softlimit))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.reverse_softlimit = struct.unpack(pattern, str[start:end])
      self.reverse_softlimit = list(map(bool, self.reverse_softlimit))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.neutral_output = struct.unpack(pattern, str[start:end])
      self.neutral_output = list(map(bool, self.neutral_output))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_top_level_buffer_count = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_top_level_buffer_full = struct.unpack(pattern, str[start:end])
      self.motion_profile_top_level_buffer_full = list(map(bool, self.motion_profile_top_level_buffer_full))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_top_buffer_rem = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_top_buffer_cnt = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_btm_buffer_cnt = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_has_underrun = struct.unpack(pattern, str[start:end])
      self.motion_profile_status_has_underrun = list(map(bool, self.motion_profile_status_has_underrun))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_is_underrun = struct.unpack(pattern, str[start:end])
      self.motion_profile_status_is_underrun = list(map(bool, self.motion_profile_status_is_underrun))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_active_point_valid = struct.unpack(pattern, str[start:end])
      self.motion_profile_status_active_point_valid = list(map(bool, self.motion_profile_status_active_point_valid))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_is_last = struct.unpack(pattern, str[start:end])
      self.motion_profile_status_is_last = list(map(bool, self.motion_profile_status_is_last))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_profile_slot_select0 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_profile_slot_select1 = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.motion_profile_status_output_enable = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.motion_profile_status_output_enable.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_time_dur_ms = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.faults = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.faults.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sticky_faults = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sticky_faults.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.conversion_factor = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_profile_status = []
      for i in range(0, length):
        val1 = talon_state_msgs.msg.CustomProfileStatus()
        _x = val1
        start = end
        end += 5
        (_x.running, _x.slotRunning,) = _get_struct_Bi().unpack(str[start:end])
        val1.running = bool(val1.running)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.remainingPoints = struct.unpack(pattern, str[start:end])
        _x = val1
        start = end
        end += 9
        (_x.remainingTime, _x.outOfPoints,) = _get_struct_dB().unpack(str[start:end])
        val1.outOfPoints = bool(val1.outOfPoints)
        self.custom_profile_status.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.talon_mode)
      buff.write(_struct_I.pack(length))
      for val1 in self.talon_mode:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.demand1_type)
      buff.write(_struct_I.pack(length))
      for val1 in self.demand1_type:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.demand1_value)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.demand1_value.tostring())
      length = len(self.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.position.tostring())
      length = len(self.speed)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.speed.tostring())
      length = len(self.output_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.output_voltage.tostring())
      length = len(self.output_current)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.output_current.tostring())
      length = len(self.bus_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.bus_voltage.tostring())
      length = len(self.motor_output_percent)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.motor_output_percent.tostring())
      length = len(self.temperature)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.temperature.tostring())
      length = len(self.set_point)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.set_point.tostring())
      length = len(self.closed_loop_error)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.closed_loop_error.tostring())
      length = len(self.integral_accumulator)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.integral_accumulator.tostring())
      length = len(self.error_derivative)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.error_derivative.tostring())
      length = len(self.closed_loop_target)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.closed_loop_target.tostring())
      length = len(self.p_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.p_term.tostring())
      length = len(self.i_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.i_term.tostring())
      length = len(self.d_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.d_term.tostring())
      length = len(self.f_term)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.f_term.tostring())
      length = len(self.active_trajectory_position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.active_trajectory_position.tostring())
      length = len(self.active_trajectory_velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.active_trajectory_velocity.tostring())
      length = len(self.active_trajectory_arbitrary_feed_forward)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.active_trajectory_arbitrary_feed_forward.tostring())
      length = len(self.active_trajectory_heading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.active_trajectory_heading.tostring())
      length = len(self.forward_limit_switch)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.forward_limit_switch.tostring())
      length = len(self.reverse_limit_switch)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.reverse_limit_switch.tostring())
      length = len(self.forward_softlimit)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.forward_softlimit.tostring())
      length = len(self.reverse_softlimit)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.reverse_softlimit.tostring())
      length = len(self.neutral_output)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.neutral_output.tostring())
      length = len(self.motion_profile_top_level_buffer_count)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_top_level_buffer_count.tostring())
      length = len(self.motion_profile_top_level_buffer_full)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.motion_profile_top_level_buffer_full.tostring())
      length = len(self.motion_profile_status_top_buffer_rem)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_status_top_buffer_rem.tostring())
      length = len(self.motion_profile_status_top_buffer_cnt)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_status_top_buffer_cnt.tostring())
      length = len(self.motion_profile_status_btm_buffer_cnt)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_status_btm_buffer_cnt.tostring())
      length = len(self.motion_profile_status_has_underrun)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.motion_profile_status_has_underrun.tostring())
      length = len(self.motion_profile_status_is_underrun)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.motion_profile_status_is_underrun.tostring())
      length = len(self.motion_profile_status_active_point_valid)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.motion_profile_status_active_point_valid.tostring())
      length = len(self.motion_profile_status_is_last)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.motion_profile_status_is_last.tostring())
      length = len(self.motion_profile_status_profile_slot_select0)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_status_profile_slot_select0.tostring())
      length = len(self.motion_profile_status_profile_slot_select1)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_status_profile_slot_select1.tostring())
      length = len(self.motion_profile_status_output_enable)
      buff.write(_struct_I.pack(length))
      for val1 in self.motion_profile_status_output_enable:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.motion_profile_time_dur_ms)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.motion_profile_time_dur_ms.tostring())
      length = len(self.faults)
      buff.write(_struct_I.pack(length))
      for val1 in self.faults:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.sticky_faults)
      buff.write(_struct_I.pack(length))
      for val1 in self.sticky_faults:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.conversion_factor)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.conversion_factor.tostring())
      length = len(self.custom_profile_status)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_profile_status:
        _x = val1
        buff.write(_get_struct_Bi().pack(_x.running, _x.slotRunning))
        length = len(val1.remainingPoints)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.remainingPoints.tostring())
        _x = val1
        buff.write(_get_struct_dB().pack(_x.remainingTime, _x.outOfPoints))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.custom_profile_status is None:
        self.custom_profile_status = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.talon_mode = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.talon_mode.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.demand1_type = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.demand1_type.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.demand1_value = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.speed = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.output_voltage = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.output_current = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.bus_voltage = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.motor_output_percent = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.temperature = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.set_point = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_error = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.integral_accumulator = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.error_derivative = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.closed_loop_target = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.p_term = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.i_term = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.d_term = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.f_term = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_arbitrary_feed_forward = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.active_trajectory_heading = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.forward_limit_switch = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.forward_limit_switch = list(map(bool, self.forward_limit_switch))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.reverse_limit_switch = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.reverse_limit_switch = list(map(bool, self.reverse_limit_switch))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.forward_softlimit = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.forward_softlimit = list(map(bool, self.forward_softlimit))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.reverse_softlimit = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.reverse_softlimit = list(map(bool, self.reverse_softlimit))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.neutral_output = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.neutral_output = list(map(bool, self.neutral_output))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_top_level_buffer_count = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_top_level_buffer_full = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.motion_profile_top_level_buffer_full = list(map(bool, self.motion_profile_top_level_buffer_full))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_top_buffer_rem = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_top_buffer_cnt = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_btm_buffer_cnt = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_has_underrun = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.motion_profile_status_has_underrun = list(map(bool, self.motion_profile_status_has_underrun))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_is_underrun = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.motion_profile_status_is_underrun = list(map(bool, self.motion_profile_status_is_underrun))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_active_point_valid = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.motion_profile_status_active_point_valid = list(map(bool, self.motion_profile_status_active_point_valid))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_is_last = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.motion_profile_status_is_last = list(map(bool, self.motion_profile_status_is_last))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_profile_slot_select0 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_status_profile_slot_select1 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.motion_profile_status_output_enable = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.motion_profile_status_output_enable.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.motion_profile_time_dur_ms = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.faults = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.faults.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sticky_faults = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.sticky_faults.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.conversion_factor = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_profile_status = []
      for i in range(0, length):
        val1 = talon_state_msgs.msg.CustomProfileStatus()
        _x = val1
        start = end
        end += 5
        (_x.running, _x.slotRunning,) = _get_struct_Bi().unpack(str[start:end])
        val1.running = bool(val1.running)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        end += struct.calcsize(pattern)
        val1.remainingPoints = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        _x = val1
        start = end
        end += 9
        (_x.remainingTime, _x.outOfPoints,) = _get_struct_dB().unpack(str[start:end])
        val1.outOfPoints = bool(val1.outOfPoints)
        self.custom_profile_status.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_Bi = None
def _get_struct_Bi():
    global _struct_Bi
    if _struct_Bi is None:
        _struct_Bi = struct.Struct("<Bi")
    return _struct_Bi
_struct_dB = None
def _get_struct_dB():
    global _struct_dB
    if _struct_dB is None:
        _struct_dB = struct.Struct("<dB")
    return _struct_dB
