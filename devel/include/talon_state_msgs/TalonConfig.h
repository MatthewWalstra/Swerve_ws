// Generated by gencpp from file talon_state_msgs/TalonConfig.msg
// DO NOT EDIT!


#ifndef TALON_STATE_MSGS_MESSAGE_TALONCONFIG_H
#define TALON_STATE_MSGS_MESSAGE_TALONCONFIG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace talon_state_msgs
{
template <class ContainerAllocator>
struct TalonConfig_
{
  typedef TalonConfig_<ContainerAllocator> Type;

  TalonConfig_()
    : header()
    , name()
    , can_id()
    , feedback_coefficient()
    , feedback_sensor()
    , remote_feedback_sensor()
    , remote_feedback_device_id0()
    , remote_feedback_filter0()
    , remote_feedback_device_id1()
    , remote_feedback_filter1()
    , sensor_term_sum0()
    , sensor_term_sum1()
    , sensor_term_diff0()
    , sensor_term_diff1()
    , encoder_ticks_per_rotation()
    , pid_slot()
    , pid_p0()
    , pid_i0()
    , pid_d0()
    , pid_f0()
    , pid_izone0()
    , pid_allowable_closed_loop_error0()
    , pid_max_integral_accumulator0()
    , pid_closed_loop_peak_output0()
    , pid_closed_loop_period0()
    , pid_p1()
    , pid_i1()
    , pid_d1()
    , pid_f1()
    , pid_izone1()
    , pid_allowable_closed_loop_error1()
    , pid_max_integral_accumulator1()
    , pid_closed_loop_peak_output1()
    , pid_closed_loop_period1()
    , pid_p2()
    , pid_i2()
    , pid_d2()
    , pid_f2()
    , pid_izone2()
    , pid_allowable_closed_loop_error2()
    , pid_max_integral_accumulator2()
    , pid_closed_loop_peak_output2()
    , pid_closed_loop_period2()
    , pid_p3()
    , pid_i3()
    , pid_d3()
    , pid_f3()
    , pid_izone3()
    , pid_allowable_closed_loop_error3()
    , pid_max_integral_accumulator3()
    , pid_closed_loop_peak_output3()
    , pid_closed_loop_period3()
    , aux_pid_polarity()
    , invert()
    , sensorPhase()
    , neutral_mode()
    , closed_loop_ramp()
    , open_loop_ramp()
    , peak_output_forward()
    , peak_output_reverse()
    , nominal_output_forward()
    , nominal_output_reverse()
    , neutral_deadband()
    , voltage_compensation_saturation()
    , voltage_measurement_filter()
    , voltage_compensation_enable()
    , velocity_measurement_period()
    , velocity_measurement_window()
    , limit_switch_local_forward_source()
    , limit_switch_local_forward_normal()
    , limit_switch_local_reverse_source()
    , limit_switch_local_reverse_normal()
    , limit_switch_remote_forward_source()
    , limit_switch_remote_forward_normal()
    , limit_switch_remote_forward_id()
    , limit_switch_remote_reverse_source()
    , limit_switch_remote_reverse_normal()
    , limit_switch_remote_reverse_id()
    , softlimit_forward_threshold()
    , softlimit_forward_enable()
    , softlimit_reverse_threshold()
    , softlimit_reverse_enable()
    , softlimits_override_enable()
    , current_limit_peak_amps()
    , current_limit_peak_msec()
    , current_limit_continuous_amps()
    , current_limit_enable()
    , motion_cruise_velocity()
    , motion_acceleration()
    , motion_s_curve_strength()
    , status_1_general_period()
    , status_2_feedback0_period()
    , status_3_quadrature_period()
    , status_4_aintempvbat_period()
    , status_6_misc_period()
    , status_7_commstatus_period()
    , status_8_pulsewidth_period()
    , status_9_motprofbuffer_period()
    , status_10_motionmagic_period()
    , status_11_uartgadgeteer_period()
    , status_12_feedback1_period()
    , status_13_base_pidf0_period()
    , status_14_turn_pidf1_period()
    , status_15_firmwareapistatus_period()
    , control_3_general_period()
    , control_4_advanced_period()
    , control_5_feedbackoutputoverride_period()
    , control_6_motprofaddtrajpoint_period()
    , motion_profile_trajectory_period()
    , conversion_factor()
    , firmware_version()
    , water_game()  {
    }
  TalonConfig_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , name(_alloc)
    , can_id(_alloc)
    , feedback_coefficient(_alloc)
    , feedback_sensor(_alloc)
    , remote_feedback_sensor(_alloc)
    , remote_feedback_device_id0(_alloc)
    , remote_feedback_filter0(_alloc)
    , remote_feedback_device_id1(_alloc)
    , remote_feedback_filter1(_alloc)
    , sensor_term_sum0(_alloc)
    , sensor_term_sum1(_alloc)
    , sensor_term_diff0(_alloc)
    , sensor_term_diff1(_alloc)
    , encoder_ticks_per_rotation(_alloc)
    , pid_slot(_alloc)
    , pid_p0(_alloc)
    , pid_i0(_alloc)
    , pid_d0(_alloc)
    , pid_f0(_alloc)
    , pid_izone0(_alloc)
    , pid_allowable_closed_loop_error0(_alloc)
    , pid_max_integral_accumulator0(_alloc)
    , pid_closed_loop_peak_output0(_alloc)
    , pid_closed_loop_period0(_alloc)
    , pid_p1(_alloc)
    , pid_i1(_alloc)
    , pid_d1(_alloc)
    , pid_f1(_alloc)
    , pid_izone1(_alloc)
    , pid_allowable_closed_loop_error1(_alloc)
    , pid_max_integral_accumulator1(_alloc)
    , pid_closed_loop_peak_output1(_alloc)
    , pid_closed_loop_period1(_alloc)
    , pid_p2(_alloc)
    , pid_i2(_alloc)
    , pid_d2(_alloc)
    , pid_f2(_alloc)
    , pid_izone2(_alloc)
    , pid_allowable_closed_loop_error2(_alloc)
    , pid_max_integral_accumulator2(_alloc)
    , pid_closed_loop_peak_output2(_alloc)
    , pid_closed_loop_period2(_alloc)
    , pid_p3(_alloc)
    , pid_i3(_alloc)
    , pid_d3(_alloc)
    , pid_f3(_alloc)
    , pid_izone3(_alloc)
    , pid_allowable_closed_loop_error3(_alloc)
    , pid_max_integral_accumulator3(_alloc)
    , pid_closed_loop_peak_output3(_alloc)
    , pid_closed_loop_period3(_alloc)
    , aux_pid_polarity(_alloc)
    , invert(_alloc)
    , sensorPhase(_alloc)
    , neutral_mode(_alloc)
    , closed_loop_ramp(_alloc)
    , open_loop_ramp(_alloc)
    , peak_output_forward(_alloc)
    , peak_output_reverse(_alloc)
    , nominal_output_forward(_alloc)
    , nominal_output_reverse(_alloc)
    , neutral_deadband(_alloc)
    , voltage_compensation_saturation(_alloc)
    , voltage_measurement_filter(_alloc)
    , voltage_compensation_enable(_alloc)
    , velocity_measurement_period(_alloc)
    , velocity_measurement_window(_alloc)
    , limit_switch_local_forward_source(_alloc)
    , limit_switch_local_forward_normal(_alloc)
    , limit_switch_local_reverse_source(_alloc)
    , limit_switch_local_reverse_normal(_alloc)
    , limit_switch_remote_forward_source(_alloc)
    , limit_switch_remote_forward_normal(_alloc)
    , limit_switch_remote_forward_id(_alloc)
    , limit_switch_remote_reverse_source(_alloc)
    , limit_switch_remote_reverse_normal(_alloc)
    , limit_switch_remote_reverse_id(_alloc)
    , softlimit_forward_threshold(_alloc)
    , softlimit_forward_enable(_alloc)
    , softlimit_reverse_threshold(_alloc)
    , softlimit_reverse_enable(_alloc)
    , softlimits_override_enable(_alloc)
    , current_limit_peak_amps(_alloc)
    , current_limit_peak_msec(_alloc)
    , current_limit_continuous_amps(_alloc)
    , current_limit_enable(_alloc)
    , motion_cruise_velocity(_alloc)
    , motion_acceleration(_alloc)
    , motion_s_curve_strength(_alloc)
    , status_1_general_period(_alloc)
    , status_2_feedback0_period(_alloc)
    , status_3_quadrature_period(_alloc)
    , status_4_aintempvbat_period(_alloc)
    , status_6_misc_period(_alloc)
    , status_7_commstatus_period(_alloc)
    , status_8_pulsewidth_period(_alloc)
    , status_9_motprofbuffer_period(_alloc)
    , status_10_motionmagic_period(_alloc)
    , status_11_uartgadgeteer_period(_alloc)
    , status_12_feedback1_period(_alloc)
    , status_13_base_pidf0_period(_alloc)
    , status_14_turn_pidf1_period(_alloc)
    , status_15_firmwareapistatus_period(_alloc)
    , control_3_general_period(_alloc)
    , control_4_advanced_period(_alloc)
    , control_5_feedbackoutputoverride_period(_alloc)
    , control_6_motprofaddtrajpoint_period(_alloc)
    , motion_profile_trajectory_period(_alloc)
    , conversion_factor(_alloc)
    , firmware_version(_alloc)
    , water_game(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _name_type;
  _name_type name;

   typedef std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  _can_id_type;
  _can_id_type can_id;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _feedback_coefficient_type;
  _feedback_coefficient_type feedback_coefficient;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _feedback_sensor_type;
  _feedback_sensor_type feedback_sensor;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _remote_feedback_sensor_type;
  _remote_feedback_sensor_type remote_feedback_sensor;

   typedef std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  _remote_feedback_device_id0_type;
  _remote_feedback_device_id0_type remote_feedback_device_id0;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _remote_feedback_filter0_type;
  _remote_feedback_filter0_type remote_feedback_filter0;

   typedef std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  _remote_feedback_device_id1_type;
  _remote_feedback_device_id1_type remote_feedback_device_id1;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _remote_feedback_filter1_type;
  _remote_feedback_filter1_type remote_feedback_filter1;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _sensor_term_sum0_type;
  _sensor_term_sum0_type sensor_term_sum0;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _sensor_term_sum1_type;
  _sensor_term_sum1_type sensor_term_sum1;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _sensor_term_diff0_type;
  _sensor_term_diff0_type sensor_term_diff0;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _sensor_term_diff1_type;
  _sensor_term_diff1_type sensor_term_diff1;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _encoder_ticks_per_rotation_type;
  _encoder_ticks_per_rotation_type encoder_ticks_per_rotation;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_slot_type;
  _pid_slot_type pid_slot;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_p0_type;
  _pid_p0_type pid_p0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_i0_type;
  _pid_i0_type pid_i0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_d0_type;
  _pid_d0_type pid_d0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_f0_type;
  _pid_f0_type pid_f0;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_izone0_type;
  _pid_izone0_type pid_izone0;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_allowable_closed_loop_error0_type;
  _pid_allowable_closed_loop_error0_type pid_allowable_closed_loop_error0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_max_integral_accumulator0_type;
  _pid_max_integral_accumulator0_type pid_max_integral_accumulator0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_closed_loop_peak_output0_type;
  _pid_closed_loop_peak_output0_type pid_closed_loop_peak_output0;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_closed_loop_period0_type;
  _pid_closed_loop_period0_type pid_closed_loop_period0;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_p1_type;
  _pid_p1_type pid_p1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_i1_type;
  _pid_i1_type pid_i1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_d1_type;
  _pid_d1_type pid_d1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_f1_type;
  _pid_f1_type pid_f1;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_izone1_type;
  _pid_izone1_type pid_izone1;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_allowable_closed_loop_error1_type;
  _pid_allowable_closed_loop_error1_type pid_allowable_closed_loop_error1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_max_integral_accumulator1_type;
  _pid_max_integral_accumulator1_type pid_max_integral_accumulator1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_closed_loop_peak_output1_type;
  _pid_closed_loop_peak_output1_type pid_closed_loop_peak_output1;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_closed_loop_period1_type;
  _pid_closed_loop_period1_type pid_closed_loop_period1;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_p2_type;
  _pid_p2_type pid_p2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_i2_type;
  _pid_i2_type pid_i2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_d2_type;
  _pid_d2_type pid_d2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_f2_type;
  _pid_f2_type pid_f2;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_izone2_type;
  _pid_izone2_type pid_izone2;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_allowable_closed_loop_error2_type;
  _pid_allowable_closed_loop_error2_type pid_allowable_closed_loop_error2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_max_integral_accumulator2_type;
  _pid_max_integral_accumulator2_type pid_max_integral_accumulator2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_closed_loop_peak_output2_type;
  _pid_closed_loop_peak_output2_type pid_closed_loop_peak_output2;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_closed_loop_period2_type;
  _pid_closed_loop_period2_type pid_closed_loop_period2;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_p3_type;
  _pid_p3_type pid_p3;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_i3_type;
  _pid_i3_type pid_i3;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_d3_type;
  _pid_d3_type pid_d3;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_f3_type;
  _pid_f3_type pid_f3;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_izone3_type;
  _pid_izone3_type pid_izone3;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_allowable_closed_loop_error3_type;
  _pid_allowable_closed_loop_error3_type pid_allowable_closed_loop_error3;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_max_integral_accumulator3_type;
  _pid_max_integral_accumulator3_type pid_max_integral_accumulator3;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _pid_closed_loop_peak_output3_type;
  _pid_closed_loop_peak_output3_type pid_closed_loop_peak_output3;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _pid_closed_loop_period3_type;
  _pid_closed_loop_period3_type pid_closed_loop_period3;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _aux_pid_polarity_type;
  _aux_pid_polarity_type aux_pid_polarity;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _invert_type;
  _invert_type invert;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _sensorPhase_type;
  _sensorPhase_type sensorPhase;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _neutral_mode_type;
  _neutral_mode_type neutral_mode;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _closed_loop_ramp_type;
  _closed_loop_ramp_type closed_loop_ramp;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _open_loop_ramp_type;
  _open_loop_ramp_type open_loop_ramp;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _peak_output_forward_type;
  _peak_output_forward_type peak_output_forward;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _peak_output_reverse_type;
  _peak_output_reverse_type peak_output_reverse;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _nominal_output_forward_type;
  _nominal_output_forward_type nominal_output_forward;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _nominal_output_reverse_type;
  _nominal_output_reverse_type nominal_output_reverse;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _neutral_deadband_type;
  _neutral_deadband_type neutral_deadband;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _voltage_compensation_saturation_type;
  _voltage_compensation_saturation_type voltage_compensation_saturation;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _voltage_measurement_filter_type;
  _voltage_measurement_filter_type voltage_measurement_filter;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _voltage_compensation_enable_type;
  _voltage_compensation_enable_type voltage_compensation_enable;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _velocity_measurement_period_type;
  _velocity_measurement_period_type velocity_measurement_period;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _velocity_measurement_window_type;
  _velocity_measurement_window_type velocity_measurement_window;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_local_forward_source_type;
  _limit_switch_local_forward_source_type limit_switch_local_forward_source;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_local_forward_normal_type;
  _limit_switch_local_forward_normal_type limit_switch_local_forward_normal;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_local_reverse_source_type;
  _limit_switch_local_reverse_source_type limit_switch_local_reverse_source;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_local_reverse_normal_type;
  _limit_switch_local_reverse_normal_type limit_switch_local_reverse_normal;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_remote_forward_source_type;
  _limit_switch_remote_forward_source_type limit_switch_remote_forward_source;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_remote_forward_normal_type;
  _limit_switch_remote_forward_normal_type limit_switch_remote_forward_normal;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _limit_switch_remote_forward_id_type;
  _limit_switch_remote_forward_id_type limit_switch_remote_forward_id;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_remote_reverse_source_type;
  _limit_switch_remote_reverse_source_type limit_switch_remote_reverse_source;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _limit_switch_remote_reverse_normal_type;
  _limit_switch_remote_reverse_normal_type limit_switch_remote_reverse_normal;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _limit_switch_remote_reverse_id_type;
  _limit_switch_remote_reverse_id_type limit_switch_remote_reverse_id;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _softlimit_forward_threshold_type;
  _softlimit_forward_threshold_type softlimit_forward_threshold;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _softlimit_forward_enable_type;
  _softlimit_forward_enable_type softlimit_forward_enable;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _softlimit_reverse_threshold_type;
  _softlimit_reverse_threshold_type softlimit_reverse_threshold;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _softlimit_reverse_enable_type;
  _softlimit_reverse_enable_type softlimit_reverse_enable;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _softlimits_override_enable_type;
  _softlimits_override_enable_type softlimits_override_enable;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _current_limit_peak_amps_type;
  _current_limit_peak_amps_type current_limit_peak_amps;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _current_limit_peak_msec_type;
  _current_limit_peak_msec_type current_limit_peak_msec;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _current_limit_continuous_amps_type;
  _current_limit_continuous_amps_type current_limit_continuous_amps;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _current_limit_enable_type;
  _current_limit_enable_type current_limit_enable;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _motion_cruise_velocity_type;
  _motion_cruise_velocity_type motion_cruise_velocity;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _motion_acceleration_type;
  _motion_acceleration_type motion_acceleration;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_s_curve_strength_type;
  _motion_s_curve_strength_type motion_s_curve_strength;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_1_general_period_type;
  _status_1_general_period_type status_1_general_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_2_feedback0_period_type;
  _status_2_feedback0_period_type status_2_feedback0_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_3_quadrature_period_type;
  _status_3_quadrature_period_type status_3_quadrature_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_4_aintempvbat_period_type;
  _status_4_aintempvbat_period_type status_4_aintempvbat_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_6_misc_period_type;
  _status_6_misc_period_type status_6_misc_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_7_commstatus_period_type;
  _status_7_commstatus_period_type status_7_commstatus_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_8_pulsewidth_period_type;
  _status_8_pulsewidth_period_type status_8_pulsewidth_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_9_motprofbuffer_period_type;
  _status_9_motprofbuffer_period_type status_9_motprofbuffer_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_10_motionmagic_period_type;
  _status_10_motionmagic_period_type status_10_motionmagic_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_11_uartgadgeteer_period_type;
  _status_11_uartgadgeteer_period_type status_11_uartgadgeteer_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_12_feedback1_period_type;
  _status_12_feedback1_period_type status_12_feedback1_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_13_base_pidf0_period_type;
  _status_13_base_pidf0_period_type status_13_base_pidf0_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_14_turn_pidf1_period_type;
  _status_14_turn_pidf1_period_type status_14_turn_pidf1_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_15_firmwareapistatus_period_type;
  _status_15_firmwareapistatus_period_type status_15_firmwareapistatus_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _control_3_general_period_type;
  _control_3_general_period_type control_3_general_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _control_4_advanced_period_type;
  _control_4_advanced_period_type control_4_advanced_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _control_5_feedbackoutputoverride_period_type;
  _control_5_feedbackoutputoverride_period_type control_5_feedbackoutputoverride_period;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _control_6_motprofaddtrajpoint_period_type;
  _control_6_motprofaddtrajpoint_period_type control_6_motprofaddtrajpoint_period;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _motion_profile_trajectory_period_type;
  _motion_profile_trajectory_period_type motion_profile_trajectory_period;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _conversion_factor_type;
  _conversion_factor_type conversion_factor;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _firmware_version_type;
  _firmware_version_type firmware_version;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _water_game_type;
  _water_game_type water_game;





  typedef boost::shared_ptr< ::talon_state_msgs::TalonConfig_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::talon_state_msgs::TalonConfig_<ContainerAllocator> const> ConstPtr;

}; // struct TalonConfig_

typedef ::talon_state_msgs::TalonConfig_<std::allocator<void> > TalonConfig;

typedef boost::shared_ptr< ::talon_state_msgs::TalonConfig > TalonConfigPtr;
typedef boost::shared_ptr< ::talon_state_msgs::TalonConfig const> TalonConfigConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::talon_state_msgs::TalonConfig_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::talon_state_msgs::TalonConfig_<ContainerAllocator1> & lhs, const ::talon_state_msgs::TalonConfig_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.name == rhs.name &&
    lhs.can_id == rhs.can_id &&
    lhs.feedback_coefficient == rhs.feedback_coefficient &&
    lhs.feedback_sensor == rhs.feedback_sensor &&
    lhs.remote_feedback_sensor == rhs.remote_feedback_sensor &&
    lhs.remote_feedback_device_id0 == rhs.remote_feedback_device_id0 &&
    lhs.remote_feedback_filter0 == rhs.remote_feedback_filter0 &&
    lhs.remote_feedback_device_id1 == rhs.remote_feedback_device_id1 &&
    lhs.remote_feedback_filter1 == rhs.remote_feedback_filter1 &&
    lhs.sensor_term_sum0 == rhs.sensor_term_sum0 &&
    lhs.sensor_term_sum1 == rhs.sensor_term_sum1 &&
    lhs.sensor_term_diff0 == rhs.sensor_term_diff0 &&
    lhs.sensor_term_diff1 == rhs.sensor_term_diff1 &&
    lhs.encoder_ticks_per_rotation == rhs.encoder_ticks_per_rotation &&
    lhs.pid_slot == rhs.pid_slot &&
    lhs.pid_p0 == rhs.pid_p0 &&
    lhs.pid_i0 == rhs.pid_i0 &&
    lhs.pid_d0 == rhs.pid_d0 &&
    lhs.pid_f0 == rhs.pid_f0 &&
    lhs.pid_izone0 == rhs.pid_izone0 &&
    lhs.pid_allowable_closed_loop_error0 == rhs.pid_allowable_closed_loop_error0 &&
    lhs.pid_max_integral_accumulator0 == rhs.pid_max_integral_accumulator0 &&
    lhs.pid_closed_loop_peak_output0 == rhs.pid_closed_loop_peak_output0 &&
    lhs.pid_closed_loop_period0 == rhs.pid_closed_loop_period0 &&
    lhs.pid_p1 == rhs.pid_p1 &&
    lhs.pid_i1 == rhs.pid_i1 &&
    lhs.pid_d1 == rhs.pid_d1 &&
    lhs.pid_f1 == rhs.pid_f1 &&
    lhs.pid_izone1 == rhs.pid_izone1 &&
    lhs.pid_allowable_closed_loop_error1 == rhs.pid_allowable_closed_loop_error1 &&
    lhs.pid_max_integral_accumulator1 == rhs.pid_max_integral_accumulator1 &&
    lhs.pid_closed_loop_peak_output1 == rhs.pid_closed_loop_peak_output1 &&
    lhs.pid_closed_loop_period1 == rhs.pid_closed_loop_period1 &&
    lhs.pid_p2 == rhs.pid_p2 &&
    lhs.pid_i2 == rhs.pid_i2 &&
    lhs.pid_d2 == rhs.pid_d2 &&
    lhs.pid_f2 == rhs.pid_f2 &&
    lhs.pid_izone2 == rhs.pid_izone2 &&
    lhs.pid_allowable_closed_loop_error2 == rhs.pid_allowable_closed_loop_error2 &&
    lhs.pid_max_integral_accumulator2 == rhs.pid_max_integral_accumulator2 &&
    lhs.pid_closed_loop_peak_output2 == rhs.pid_closed_loop_peak_output2 &&
    lhs.pid_closed_loop_period2 == rhs.pid_closed_loop_period2 &&
    lhs.pid_p3 == rhs.pid_p3 &&
    lhs.pid_i3 == rhs.pid_i3 &&
    lhs.pid_d3 == rhs.pid_d3 &&
    lhs.pid_f3 == rhs.pid_f3 &&
    lhs.pid_izone3 == rhs.pid_izone3 &&
    lhs.pid_allowable_closed_loop_error3 == rhs.pid_allowable_closed_loop_error3 &&
    lhs.pid_max_integral_accumulator3 == rhs.pid_max_integral_accumulator3 &&
    lhs.pid_closed_loop_peak_output3 == rhs.pid_closed_loop_peak_output3 &&
    lhs.pid_closed_loop_period3 == rhs.pid_closed_loop_period3 &&
    lhs.aux_pid_polarity == rhs.aux_pid_polarity &&
    lhs.invert == rhs.invert &&
    lhs.sensorPhase == rhs.sensorPhase &&
    lhs.neutral_mode == rhs.neutral_mode &&
    lhs.closed_loop_ramp == rhs.closed_loop_ramp &&
    lhs.open_loop_ramp == rhs.open_loop_ramp &&
    lhs.peak_output_forward == rhs.peak_output_forward &&
    lhs.peak_output_reverse == rhs.peak_output_reverse &&
    lhs.nominal_output_forward == rhs.nominal_output_forward &&
    lhs.nominal_output_reverse == rhs.nominal_output_reverse &&
    lhs.neutral_deadband == rhs.neutral_deadband &&
    lhs.voltage_compensation_saturation == rhs.voltage_compensation_saturation &&
    lhs.voltage_measurement_filter == rhs.voltage_measurement_filter &&
    lhs.voltage_compensation_enable == rhs.voltage_compensation_enable &&
    lhs.velocity_measurement_period == rhs.velocity_measurement_period &&
    lhs.velocity_measurement_window == rhs.velocity_measurement_window &&
    lhs.limit_switch_local_forward_source == rhs.limit_switch_local_forward_source &&
    lhs.limit_switch_local_forward_normal == rhs.limit_switch_local_forward_normal &&
    lhs.limit_switch_local_reverse_source == rhs.limit_switch_local_reverse_source &&
    lhs.limit_switch_local_reverse_normal == rhs.limit_switch_local_reverse_normal &&
    lhs.limit_switch_remote_forward_source == rhs.limit_switch_remote_forward_source &&
    lhs.limit_switch_remote_forward_normal == rhs.limit_switch_remote_forward_normal &&
    lhs.limit_switch_remote_forward_id == rhs.limit_switch_remote_forward_id &&
    lhs.limit_switch_remote_reverse_source == rhs.limit_switch_remote_reverse_source &&
    lhs.limit_switch_remote_reverse_normal == rhs.limit_switch_remote_reverse_normal &&
    lhs.limit_switch_remote_reverse_id == rhs.limit_switch_remote_reverse_id &&
    lhs.softlimit_forward_threshold == rhs.softlimit_forward_threshold &&
    lhs.softlimit_forward_enable == rhs.softlimit_forward_enable &&
    lhs.softlimit_reverse_threshold == rhs.softlimit_reverse_threshold &&
    lhs.softlimit_reverse_enable == rhs.softlimit_reverse_enable &&
    lhs.softlimits_override_enable == rhs.softlimits_override_enable &&
    lhs.current_limit_peak_amps == rhs.current_limit_peak_amps &&
    lhs.current_limit_peak_msec == rhs.current_limit_peak_msec &&
    lhs.current_limit_continuous_amps == rhs.current_limit_continuous_amps &&
    lhs.current_limit_enable == rhs.current_limit_enable &&
    lhs.motion_cruise_velocity == rhs.motion_cruise_velocity &&
    lhs.motion_acceleration == rhs.motion_acceleration &&
    lhs.motion_s_curve_strength == rhs.motion_s_curve_strength &&
    lhs.status_1_general_period == rhs.status_1_general_period &&
    lhs.status_2_feedback0_period == rhs.status_2_feedback0_period &&
    lhs.status_3_quadrature_period == rhs.status_3_quadrature_period &&
    lhs.status_4_aintempvbat_period == rhs.status_4_aintempvbat_period &&
    lhs.status_6_misc_period == rhs.status_6_misc_period &&
    lhs.status_7_commstatus_period == rhs.status_7_commstatus_period &&
    lhs.status_8_pulsewidth_period == rhs.status_8_pulsewidth_period &&
    lhs.status_9_motprofbuffer_period == rhs.status_9_motprofbuffer_period &&
    lhs.status_10_motionmagic_period == rhs.status_10_motionmagic_period &&
    lhs.status_11_uartgadgeteer_period == rhs.status_11_uartgadgeteer_period &&
    lhs.status_12_feedback1_period == rhs.status_12_feedback1_period &&
    lhs.status_13_base_pidf0_period == rhs.status_13_base_pidf0_period &&
    lhs.status_14_turn_pidf1_period == rhs.status_14_turn_pidf1_period &&
    lhs.status_15_firmwareapistatus_period == rhs.status_15_firmwareapistatus_period &&
    lhs.control_3_general_period == rhs.control_3_general_period &&
    lhs.control_4_advanced_period == rhs.control_4_advanced_period &&
    lhs.control_5_feedbackoutputoverride_period == rhs.control_5_feedbackoutputoverride_period &&
    lhs.control_6_motprofaddtrajpoint_period == rhs.control_6_motprofaddtrajpoint_period &&
    lhs.motion_profile_trajectory_period == rhs.motion_profile_trajectory_period &&
    lhs.conversion_factor == rhs.conversion_factor &&
    lhs.firmware_version == rhs.firmware_version &&
    lhs.water_game == rhs.water_game;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::talon_state_msgs::TalonConfig_<ContainerAllocator1> & lhs, const ::talon_state_msgs::TalonConfig_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace talon_state_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::talon_state_msgs::TalonConfig_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::talon_state_msgs::TalonConfig_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::talon_state_msgs::TalonConfig_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c581b95d041ee8a7724c07ef2b96b2da";
  }

  static const char* value(const ::talon_state_msgs::TalonConfig_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc581b95d041ee8a7ULL;
  static const uint64_t static_value2 = 0x724c07ef2b96b2daULL;
};

template<class ContainerAllocator>
struct DataType< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
{
  static const char* value()
  {
    return "talon_state_msgs/TalonConfig";
  }

  static const char* value(const ::talon_state_msgs::TalonConfig_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"string[] name\n"
"int8[] can_id\n"
"float64[] feedback_coefficient\n"
"string[]  feedback_sensor\n"
"string[]  remote_feedback_sensor\n"
"int8[]    remote_feedback_device_id0\n"
"string[]  remote_feedback_filter0\n"
"int8[]    remote_feedback_device_id1\n"
"string[]  remote_feedback_filter1\n"
"string[]  sensor_term_sum0\n"
"string[]  sensor_term_sum1\n"
"string[]  sensor_term_diff0\n"
"string[]  sensor_term_diff1\n"
"int32[]   encoder_ticks_per_rotation\n"
"int32[]   pid_slot\n"
"float64[] pid_p0\n"
"float64[] pid_i0\n"
"float64[] pid_d0\n"
"float64[] pid_f0\n"
"int32[] pid_izone0\n"
"int32[] pid_allowable_closed_loop_error0\n"
"float64[] pid_max_integral_accumulator0\n"
"float64[] pid_closed_loop_peak_output0\n"
"int32[]   pid_closed_loop_period0\n"
"float64[] pid_p1\n"
"float64[] pid_i1\n"
"float64[] pid_d1\n"
"float64[] pid_f1\n"
"int32[] pid_izone1\n"
"int32[] pid_allowable_closed_loop_error1\n"
"float64[] pid_max_integral_accumulator1\n"
"float64[] pid_closed_loop_peak_output1\n"
"int32[]   pid_closed_loop_period1\n"
"float64[] pid_p2\n"
"float64[] pid_i2\n"
"float64[] pid_d2\n"
"float64[] pid_f2\n"
"int32[] pid_izone2\n"
"int32[] pid_allowable_closed_loop_error2\n"
"float64[] pid_max_integral_accumulator2\n"
"float64[] pid_closed_loop_peak_output2\n"
"int32[]   pid_closed_loop_period2\n"
"float64[] pid_p3\n"
"float64[] pid_i3\n"
"float64[] pid_d3\n"
"float64[] pid_f3\n"
"int32[] pid_izone3\n"
"int32[] pid_allowable_closed_loop_error3\n"
"float64[] pid_max_integral_accumulator3\n"
"float64[] pid_closed_loop_peak_output3\n"
"int32[]   pid_closed_loop_period3\n"
"bool[]    aux_pid_polarity\n"
"bool[] invert\n"
"bool[] sensorPhase\n"
"string[] neutral_mode\n"
"float64[] closed_loop_ramp\n"
"float64[] open_loop_ramp\n"
"float64[] peak_output_forward\n"
"float64[] peak_output_reverse\n"
"float64[] nominal_output_forward\n"
"float64[] nominal_output_reverse\n"
"float64[] neutral_deadband\n"
"float64[] voltage_compensation_saturation\n"
"int32[]   voltage_measurement_filter\n"
"bool[]    voltage_compensation_enable\n"
"int32[]   velocity_measurement_period\n"
"int32[]   velocity_measurement_window\n"
"string[]  limit_switch_local_forward_source\n"
"string[]  limit_switch_local_forward_normal\n"
"string[]  limit_switch_local_reverse_source\n"
"string[]  limit_switch_local_reverse_normal\n"
"string[]  limit_switch_remote_forward_source\n"
"string[]  limit_switch_remote_forward_normal\n"
"uint8[]   limit_switch_remote_forward_id\n"
"string[]  limit_switch_remote_reverse_source\n"
"string[]  limit_switch_remote_reverse_normal\n"
"uint8[]   limit_switch_remote_reverse_id\n"
"float64[] softlimit_forward_threshold\n"
"bool[]    softlimit_forward_enable\n"
"float64[] softlimit_reverse_threshold\n"
"bool[]    softlimit_reverse_enable\n"
"bool[]    softlimits_override_enable\n"
"int32[]   current_limit_peak_amps\n"
"int32[]   current_limit_peak_msec\n"
"int32[]   current_limit_continuous_amps\n"
"bool[]    current_limit_enable\n"
"float64[] motion_cruise_velocity\n"
"float64[] motion_acceleration\n"
"uint8[]   motion_s_curve_strength\n"
"uint8[]   status_1_general_period\n"
"uint8[]   status_2_feedback0_period\n"
"uint8[]   status_3_quadrature_period\n"
"uint8[]   status_4_aintempvbat_period\n"
"uint8[]   status_6_misc_period\n"
"uint8[]   status_7_commstatus_period\n"
"uint8[]   status_8_pulsewidth_period\n"
"uint8[]   status_9_motprofbuffer_period\n"
"uint8[]   status_10_motionmagic_period\n"
"uint8[]   status_11_uartgadgeteer_period\n"
"uint8[]   status_12_feedback1_period\n"
"uint8[]   status_13_base_pidf0_period\n"
"uint8[]   status_14_turn_pidf1_period\n"
"uint8[]   status_15_firmwareapistatus_period\n"
"uint8[]   control_3_general_period\n"
"uint8[]   control_4_advanced_period\n"
"uint8[]   control_5_feedbackoutputoverride_period\n"
"uint8[]   control_6_motprofaddtrajpoint_period\n"
"float64[] motion_profile_trajectory_period\n"
"float64[] conversion_factor\n"
"string[]  firmware_version\n"
"bool[]    water_game\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::talon_state_msgs::TalonConfig_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.name);
      stream.next(m.can_id);
      stream.next(m.feedback_coefficient);
      stream.next(m.feedback_sensor);
      stream.next(m.remote_feedback_sensor);
      stream.next(m.remote_feedback_device_id0);
      stream.next(m.remote_feedback_filter0);
      stream.next(m.remote_feedback_device_id1);
      stream.next(m.remote_feedback_filter1);
      stream.next(m.sensor_term_sum0);
      stream.next(m.sensor_term_sum1);
      stream.next(m.sensor_term_diff0);
      stream.next(m.sensor_term_diff1);
      stream.next(m.encoder_ticks_per_rotation);
      stream.next(m.pid_slot);
      stream.next(m.pid_p0);
      stream.next(m.pid_i0);
      stream.next(m.pid_d0);
      stream.next(m.pid_f0);
      stream.next(m.pid_izone0);
      stream.next(m.pid_allowable_closed_loop_error0);
      stream.next(m.pid_max_integral_accumulator0);
      stream.next(m.pid_closed_loop_peak_output0);
      stream.next(m.pid_closed_loop_period0);
      stream.next(m.pid_p1);
      stream.next(m.pid_i1);
      stream.next(m.pid_d1);
      stream.next(m.pid_f1);
      stream.next(m.pid_izone1);
      stream.next(m.pid_allowable_closed_loop_error1);
      stream.next(m.pid_max_integral_accumulator1);
      stream.next(m.pid_closed_loop_peak_output1);
      stream.next(m.pid_closed_loop_period1);
      stream.next(m.pid_p2);
      stream.next(m.pid_i2);
      stream.next(m.pid_d2);
      stream.next(m.pid_f2);
      stream.next(m.pid_izone2);
      stream.next(m.pid_allowable_closed_loop_error2);
      stream.next(m.pid_max_integral_accumulator2);
      stream.next(m.pid_closed_loop_peak_output2);
      stream.next(m.pid_closed_loop_period2);
      stream.next(m.pid_p3);
      stream.next(m.pid_i3);
      stream.next(m.pid_d3);
      stream.next(m.pid_f3);
      stream.next(m.pid_izone3);
      stream.next(m.pid_allowable_closed_loop_error3);
      stream.next(m.pid_max_integral_accumulator3);
      stream.next(m.pid_closed_loop_peak_output3);
      stream.next(m.pid_closed_loop_period3);
      stream.next(m.aux_pid_polarity);
      stream.next(m.invert);
      stream.next(m.sensorPhase);
      stream.next(m.neutral_mode);
      stream.next(m.closed_loop_ramp);
      stream.next(m.open_loop_ramp);
      stream.next(m.peak_output_forward);
      stream.next(m.peak_output_reverse);
      stream.next(m.nominal_output_forward);
      stream.next(m.nominal_output_reverse);
      stream.next(m.neutral_deadband);
      stream.next(m.voltage_compensation_saturation);
      stream.next(m.voltage_measurement_filter);
      stream.next(m.voltage_compensation_enable);
      stream.next(m.velocity_measurement_period);
      stream.next(m.velocity_measurement_window);
      stream.next(m.limit_switch_local_forward_source);
      stream.next(m.limit_switch_local_forward_normal);
      stream.next(m.limit_switch_local_reverse_source);
      stream.next(m.limit_switch_local_reverse_normal);
      stream.next(m.limit_switch_remote_forward_source);
      stream.next(m.limit_switch_remote_forward_normal);
      stream.next(m.limit_switch_remote_forward_id);
      stream.next(m.limit_switch_remote_reverse_source);
      stream.next(m.limit_switch_remote_reverse_normal);
      stream.next(m.limit_switch_remote_reverse_id);
      stream.next(m.softlimit_forward_threshold);
      stream.next(m.softlimit_forward_enable);
      stream.next(m.softlimit_reverse_threshold);
      stream.next(m.softlimit_reverse_enable);
      stream.next(m.softlimits_override_enable);
      stream.next(m.current_limit_peak_amps);
      stream.next(m.current_limit_peak_msec);
      stream.next(m.current_limit_continuous_amps);
      stream.next(m.current_limit_enable);
      stream.next(m.motion_cruise_velocity);
      stream.next(m.motion_acceleration);
      stream.next(m.motion_s_curve_strength);
      stream.next(m.status_1_general_period);
      stream.next(m.status_2_feedback0_period);
      stream.next(m.status_3_quadrature_period);
      stream.next(m.status_4_aintempvbat_period);
      stream.next(m.status_6_misc_period);
      stream.next(m.status_7_commstatus_period);
      stream.next(m.status_8_pulsewidth_period);
      stream.next(m.status_9_motprofbuffer_period);
      stream.next(m.status_10_motionmagic_period);
      stream.next(m.status_11_uartgadgeteer_period);
      stream.next(m.status_12_feedback1_period);
      stream.next(m.status_13_base_pidf0_period);
      stream.next(m.status_14_turn_pidf1_period);
      stream.next(m.status_15_firmwareapistatus_period);
      stream.next(m.control_3_general_period);
      stream.next(m.control_4_advanced_period);
      stream.next(m.control_5_feedbackoutputoverride_period);
      stream.next(m.control_6_motprofaddtrajpoint_period);
      stream.next(m.motion_profile_trajectory_period);
      stream.next(m.conversion_factor);
      stream.next(m.firmware_version);
      stream.next(m.water_game);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TalonConfig_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::talon_state_msgs::TalonConfig_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::talon_state_msgs::TalonConfig_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "name[]" << std::endl;
    for (size_t i = 0; i < v.name.size(); ++i)
    {
      s << indent << "  name[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.name[i]);
    }
    s << indent << "can_id[]" << std::endl;
    for (size_t i = 0; i < v.can_id.size(); ++i)
    {
      s << indent << "  can_id[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.can_id[i]);
    }
    s << indent << "feedback_coefficient[]" << std::endl;
    for (size_t i = 0; i < v.feedback_coefficient.size(); ++i)
    {
      s << indent << "  feedback_coefficient[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.feedback_coefficient[i]);
    }
    s << indent << "feedback_sensor[]" << std::endl;
    for (size_t i = 0; i < v.feedback_sensor.size(); ++i)
    {
      s << indent << "  feedback_sensor[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.feedback_sensor[i]);
    }
    s << indent << "remote_feedback_sensor[]" << std::endl;
    for (size_t i = 0; i < v.remote_feedback_sensor.size(); ++i)
    {
      s << indent << "  remote_feedback_sensor[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.remote_feedback_sensor[i]);
    }
    s << indent << "remote_feedback_device_id0[]" << std::endl;
    for (size_t i = 0; i < v.remote_feedback_device_id0.size(); ++i)
    {
      s << indent << "  remote_feedback_device_id0[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.remote_feedback_device_id0[i]);
    }
    s << indent << "remote_feedback_filter0[]" << std::endl;
    for (size_t i = 0; i < v.remote_feedback_filter0.size(); ++i)
    {
      s << indent << "  remote_feedback_filter0[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.remote_feedback_filter0[i]);
    }
    s << indent << "remote_feedback_device_id1[]" << std::endl;
    for (size_t i = 0; i < v.remote_feedback_device_id1.size(); ++i)
    {
      s << indent << "  remote_feedback_device_id1[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.remote_feedback_device_id1[i]);
    }
    s << indent << "remote_feedback_filter1[]" << std::endl;
    for (size_t i = 0; i < v.remote_feedback_filter1.size(); ++i)
    {
      s << indent << "  remote_feedback_filter1[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.remote_feedback_filter1[i]);
    }
    s << indent << "sensor_term_sum0[]" << std::endl;
    for (size_t i = 0; i < v.sensor_term_sum0.size(); ++i)
    {
      s << indent << "  sensor_term_sum0[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sensor_term_sum0[i]);
    }
    s << indent << "sensor_term_sum1[]" << std::endl;
    for (size_t i = 0; i < v.sensor_term_sum1.size(); ++i)
    {
      s << indent << "  sensor_term_sum1[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sensor_term_sum1[i]);
    }
    s << indent << "sensor_term_diff0[]" << std::endl;
    for (size_t i = 0; i < v.sensor_term_diff0.size(); ++i)
    {
      s << indent << "  sensor_term_diff0[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sensor_term_diff0[i]);
    }
    s << indent << "sensor_term_diff1[]" << std::endl;
    for (size_t i = 0; i < v.sensor_term_diff1.size(); ++i)
    {
      s << indent << "  sensor_term_diff1[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sensor_term_diff1[i]);
    }
    s << indent << "encoder_ticks_per_rotation[]" << std::endl;
    for (size_t i = 0; i < v.encoder_ticks_per_rotation.size(); ++i)
    {
      s << indent << "  encoder_ticks_per_rotation[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.encoder_ticks_per_rotation[i]);
    }
    s << indent << "pid_slot[]" << std::endl;
    for (size_t i = 0; i < v.pid_slot.size(); ++i)
    {
      s << indent << "  pid_slot[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_slot[i]);
    }
    s << indent << "pid_p0[]" << std::endl;
    for (size_t i = 0; i < v.pid_p0.size(); ++i)
    {
      s << indent << "  pid_p0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_p0[i]);
    }
    s << indent << "pid_i0[]" << std::endl;
    for (size_t i = 0; i < v.pid_i0.size(); ++i)
    {
      s << indent << "  pid_i0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_i0[i]);
    }
    s << indent << "pid_d0[]" << std::endl;
    for (size_t i = 0; i < v.pid_d0.size(); ++i)
    {
      s << indent << "  pid_d0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_d0[i]);
    }
    s << indent << "pid_f0[]" << std::endl;
    for (size_t i = 0; i < v.pid_f0.size(); ++i)
    {
      s << indent << "  pid_f0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_f0[i]);
    }
    s << indent << "pid_izone0[]" << std::endl;
    for (size_t i = 0; i < v.pid_izone0.size(); ++i)
    {
      s << indent << "  pid_izone0[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_izone0[i]);
    }
    s << indent << "pid_allowable_closed_loop_error0[]" << std::endl;
    for (size_t i = 0; i < v.pid_allowable_closed_loop_error0.size(); ++i)
    {
      s << indent << "  pid_allowable_closed_loop_error0[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_allowable_closed_loop_error0[i]);
    }
    s << indent << "pid_max_integral_accumulator0[]" << std::endl;
    for (size_t i = 0; i < v.pid_max_integral_accumulator0.size(); ++i)
    {
      s << indent << "  pid_max_integral_accumulator0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_max_integral_accumulator0[i]);
    }
    s << indent << "pid_closed_loop_peak_output0[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_peak_output0.size(); ++i)
    {
      s << indent << "  pid_closed_loop_peak_output0[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_closed_loop_peak_output0[i]);
    }
    s << indent << "pid_closed_loop_period0[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_period0.size(); ++i)
    {
      s << indent << "  pid_closed_loop_period0[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_closed_loop_period0[i]);
    }
    s << indent << "pid_p1[]" << std::endl;
    for (size_t i = 0; i < v.pid_p1.size(); ++i)
    {
      s << indent << "  pid_p1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_p1[i]);
    }
    s << indent << "pid_i1[]" << std::endl;
    for (size_t i = 0; i < v.pid_i1.size(); ++i)
    {
      s << indent << "  pid_i1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_i1[i]);
    }
    s << indent << "pid_d1[]" << std::endl;
    for (size_t i = 0; i < v.pid_d1.size(); ++i)
    {
      s << indent << "  pid_d1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_d1[i]);
    }
    s << indent << "pid_f1[]" << std::endl;
    for (size_t i = 0; i < v.pid_f1.size(); ++i)
    {
      s << indent << "  pid_f1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_f1[i]);
    }
    s << indent << "pid_izone1[]" << std::endl;
    for (size_t i = 0; i < v.pid_izone1.size(); ++i)
    {
      s << indent << "  pid_izone1[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_izone1[i]);
    }
    s << indent << "pid_allowable_closed_loop_error1[]" << std::endl;
    for (size_t i = 0; i < v.pid_allowable_closed_loop_error1.size(); ++i)
    {
      s << indent << "  pid_allowable_closed_loop_error1[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_allowable_closed_loop_error1[i]);
    }
    s << indent << "pid_max_integral_accumulator1[]" << std::endl;
    for (size_t i = 0; i < v.pid_max_integral_accumulator1.size(); ++i)
    {
      s << indent << "  pid_max_integral_accumulator1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_max_integral_accumulator1[i]);
    }
    s << indent << "pid_closed_loop_peak_output1[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_peak_output1.size(); ++i)
    {
      s << indent << "  pid_closed_loop_peak_output1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_closed_loop_peak_output1[i]);
    }
    s << indent << "pid_closed_loop_period1[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_period1.size(); ++i)
    {
      s << indent << "  pid_closed_loop_period1[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_closed_loop_period1[i]);
    }
    s << indent << "pid_p2[]" << std::endl;
    for (size_t i = 0; i < v.pid_p2.size(); ++i)
    {
      s << indent << "  pid_p2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_p2[i]);
    }
    s << indent << "pid_i2[]" << std::endl;
    for (size_t i = 0; i < v.pid_i2.size(); ++i)
    {
      s << indent << "  pid_i2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_i2[i]);
    }
    s << indent << "pid_d2[]" << std::endl;
    for (size_t i = 0; i < v.pid_d2.size(); ++i)
    {
      s << indent << "  pid_d2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_d2[i]);
    }
    s << indent << "pid_f2[]" << std::endl;
    for (size_t i = 0; i < v.pid_f2.size(); ++i)
    {
      s << indent << "  pid_f2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_f2[i]);
    }
    s << indent << "pid_izone2[]" << std::endl;
    for (size_t i = 0; i < v.pid_izone2.size(); ++i)
    {
      s << indent << "  pid_izone2[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_izone2[i]);
    }
    s << indent << "pid_allowable_closed_loop_error2[]" << std::endl;
    for (size_t i = 0; i < v.pid_allowable_closed_loop_error2.size(); ++i)
    {
      s << indent << "  pid_allowable_closed_loop_error2[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_allowable_closed_loop_error2[i]);
    }
    s << indent << "pid_max_integral_accumulator2[]" << std::endl;
    for (size_t i = 0; i < v.pid_max_integral_accumulator2.size(); ++i)
    {
      s << indent << "  pid_max_integral_accumulator2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_max_integral_accumulator2[i]);
    }
    s << indent << "pid_closed_loop_peak_output2[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_peak_output2.size(); ++i)
    {
      s << indent << "  pid_closed_loop_peak_output2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_closed_loop_peak_output2[i]);
    }
    s << indent << "pid_closed_loop_period2[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_period2.size(); ++i)
    {
      s << indent << "  pid_closed_loop_period2[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_closed_loop_period2[i]);
    }
    s << indent << "pid_p3[]" << std::endl;
    for (size_t i = 0; i < v.pid_p3.size(); ++i)
    {
      s << indent << "  pid_p3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_p3[i]);
    }
    s << indent << "pid_i3[]" << std::endl;
    for (size_t i = 0; i < v.pid_i3.size(); ++i)
    {
      s << indent << "  pid_i3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_i3[i]);
    }
    s << indent << "pid_d3[]" << std::endl;
    for (size_t i = 0; i < v.pid_d3.size(); ++i)
    {
      s << indent << "  pid_d3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_d3[i]);
    }
    s << indent << "pid_f3[]" << std::endl;
    for (size_t i = 0; i < v.pid_f3.size(); ++i)
    {
      s << indent << "  pid_f3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_f3[i]);
    }
    s << indent << "pid_izone3[]" << std::endl;
    for (size_t i = 0; i < v.pid_izone3.size(); ++i)
    {
      s << indent << "  pid_izone3[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_izone3[i]);
    }
    s << indent << "pid_allowable_closed_loop_error3[]" << std::endl;
    for (size_t i = 0; i < v.pid_allowable_closed_loop_error3.size(); ++i)
    {
      s << indent << "  pid_allowable_closed_loop_error3[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_allowable_closed_loop_error3[i]);
    }
    s << indent << "pid_max_integral_accumulator3[]" << std::endl;
    for (size_t i = 0; i < v.pid_max_integral_accumulator3.size(); ++i)
    {
      s << indent << "  pid_max_integral_accumulator3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_max_integral_accumulator3[i]);
    }
    s << indent << "pid_closed_loop_peak_output3[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_peak_output3.size(); ++i)
    {
      s << indent << "  pid_closed_loop_peak_output3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pid_closed_loop_peak_output3[i]);
    }
    s << indent << "pid_closed_loop_period3[]" << std::endl;
    for (size_t i = 0; i < v.pid_closed_loop_period3.size(); ++i)
    {
      s << indent << "  pid_closed_loop_period3[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.pid_closed_loop_period3[i]);
    }
    s << indent << "aux_pid_polarity[]" << std::endl;
    for (size_t i = 0; i < v.aux_pid_polarity.size(); ++i)
    {
      s << indent << "  aux_pid_polarity[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.aux_pid_polarity[i]);
    }
    s << indent << "invert[]" << std::endl;
    for (size_t i = 0; i < v.invert.size(); ++i)
    {
      s << indent << "  invert[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.invert[i]);
    }
    s << indent << "sensorPhase[]" << std::endl;
    for (size_t i = 0; i < v.sensorPhase.size(); ++i)
    {
      s << indent << "  sensorPhase[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.sensorPhase[i]);
    }
    s << indent << "neutral_mode[]" << std::endl;
    for (size_t i = 0; i < v.neutral_mode.size(); ++i)
    {
      s << indent << "  neutral_mode[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.neutral_mode[i]);
    }
    s << indent << "closed_loop_ramp[]" << std::endl;
    for (size_t i = 0; i < v.closed_loop_ramp.size(); ++i)
    {
      s << indent << "  closed_loop_ramp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.closed_loop_ramp[i]);
    }
    s << indent << "open_loop_ramp[]" << std::endl;
    for (size_t i = 0; i < v.open_loop_ramp.size(); ++i)
    {
      s << indent << "  open_loop_ramp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.open_loop_ramp[i]);
    }
    s << indent << "peak_output_forward[]" << std::endl;
    for (size_t i = 0; i < v.peak_output_forward.size(); ++i)
    {
      s << indent << "  peak_output_forward[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.peak_output_forward[i]);
    }
    s << indent << "peak_output_reverse[]" << std::endl;
    for (size_t i = 0; i < v.peak_output_reverse.size(); ++i)
    {
      s << indent << "  peak_output_reverse[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.peak_output_reverse[i]);
    }
    s << indent << "nominal_output_forward[]" << std::endl;
    for (size_t i = 0; i < v.nominal_output_forward.size(); ++i)
    {
      s << indent << "  nominal_output_forward[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.nominal_output_forward[i]);
    }
    s << indent << "nominal_output_reverse[]" << std::endl;
    for (size_t i = 0; i < v.nominal_output_reverse.size(); ++i)
    {
      s << indent << "  nominal_output_reverse[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.nominal_output_reverse[i]);
    }
    s << indent << "neutral_deadband[]" << std::endl;
    for (size_t i = 0; i < v.neutral_deadband.size(); ++i)
    {
      s << indent << "  neutral_deadband[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.neutral_deadband[i]);
    }
    s << indent << "voltage_compensation_saturation[]" << std::endl;
    for (size_t i = 0; i < v.voltage_compensation_saturation.size(); ++i)
    {
      s << indent << "  voltage_compensation_saturation[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.voltage_compensation_saturation[i]);
    }
    s << indent << "voltage_measurement_filter[]" << std::endl;
    for (size_t i = 0; i < v.voltage_measurement_filter.size(); ++i)
    {
      s << indent << "  voltage_measurement_filter[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.voltage_measurement_filter[i]);
    }
    s << indent << "voltage_compensation_enable[]" << std::endl;
    for (size_t i = 0; i < v.voltage_compensation_enable.size(); ++i)
    {
      s << indent << "  voltage_compensation_enable[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.voltage_compensation_enable[i]);
    }
    s << indent << "velocity_measurement_period[]" << std::endl;
    for (size_t i = 0; i < v.velocity_measurement_period.size(); ++i)
    {
      s << indent << "  velocity_measurement_period[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.velocity_measurement_period[i]);
    }
    s << indent << "velocity_measurement_window[]" << std::endl;
    for (size_t i = 0; i < v.velocity_measurement_window.size(); ++i)
    {
      s << indent << "  velocity_measurement_window[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.velocity_measurement_window[i]);
    }
    s << indent << "limit_switch_local_forward_source[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_local_forward_source.size(); ++i)
    {
      s << indent << "  limit_switch_local_forward_source[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_local_forward_source[i]);
    }
    s << indent << "limit_switch_local_forward_normal[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_local_forward_normal.size(); ++i)
    {
      s << indent << "  limit_switch_local_forward_normal[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_local_forward_normal[i]);
    }
    s << indent << "limit_switch_local_reverse_source[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_local_reverse_source.size(); ++i)
    {
      s << indent << "  limit_switch_local_reverse_source[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_local_reverse_source[i]);
    }
    s << indent << "limit_switch_local_reverse_normal[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_local_reverse_normal.size(); ++i)
    {
      s << indent << "  limit_switch_local_reverse_normal[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_local_reverse_normal[i]);
    }
    s << indent << "limit_switch_remote_forward_source[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_forward_source.size(); ++i)
    {
      s << indent << "  limit_switch_remote_forward_source[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_remote_forward_source[i]);
    }
    s << indent << "limit_switch_remote_forward_normal[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_forward_normal.size(); ++i)
    {
      s << indent << "  limit_switch_remote_forward_normal[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_remote_forward_normal[i]);
    }
    s << indent << "limit_switch_remote_forward_id[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_forward_id.size(); ++i)
    {
      s << indent << "  limit_switch_remote_forward_id[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.limit_switch_remote_forward_id[i]);
    }
    s << indent << "limit_switch_remote_reverse_source[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_reverse_source.size(); ++i)
    {
      s << indent << "  limit_switch_remote_reverse_source[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_remote_reverse_source[i]);
    }
    s << indent << "limit_switch_remote_reverse_normal[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_reverse_normal.size(); ++i)
    {
      s << indent << "  limit_switch_remote_reverse_normal[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.limit_switch_remote_reverse_normal[i]);
    }
    s << indent << "limit_switch_remote_reverse_id[]" << std::endl;
    for (size_t i = 0; i < v.limit_switch_remote_reverse_id.size(); ++i)
    {
      s << indent << "  limit_switch_remote_reverse_id[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.limit_switch_remote_reverse_id[i]);
    }
    s << indent << "softlimit_forward_threshold[]" << std::endl;
    for (size_t i = 0; i < v.softlimit_forward_threshold.size(); ++i)
    {
      s << indent << "  softlimit_forward_threshold[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.softlimit_forward_threshold[i]);
    }
    s << indent << "softlimit_forward_enable[]" << std::endl;
    for (size_t i = 0; i < v.softlimit_forward_enable.size(); ++i)
    {
      s << indent << "  softlimit_forward_enable[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.softlimit_forward_enable[i]);
    }
    s << indent << "softlimit_reverse_threshold[]" << std::endl;
    for (size_t i = 0; i < v.softlimit_reverse_threshold.size(); ++i)
    {
      s << indent << "  softlimit_reverse_threshold[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.softlimit_reverse_threshold[i]);
    }
    s << indent << "softlimit_reverse_enable[]" << std::endl;
    for (size_t i = 0; i < v.softlimit_reverse_enable.size(); ++i)
    {
      s << indent << "  softlimit_reverse_enable[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.softlimit_reverse_enable[i]);
    }
    s << indent << "softlimits_override_enable[]" << std::endl;
    for (size_t i = 0; i < v.softlimits_override_enable.size(); ++i)
    {
      s << indent << "  softlimits_override_enable[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.softlimits_override_enable[i]);
    }
    s << indent << "current_limit_peak_amps[]" << std::endl;
    for (size_t i = 0; i < v.current_limit_peak_amps.size(); ++i)
    {
      s << indent << "  current_limit_peak_amps[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.current_limit_peak_amps[i]);
    }
    s << indent << "current_limit_peak_msec[]" << std::endl;
    for (size_t i = 0; i < v.current_limit_peak_msec.size(); ++i)
    {
      s << indent << "  current_limit_peak_msec[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.current_limit_peak_msec[i]);
    }
    s << indent << "current_limit_continuous_amps[]" << std::endl;
    for (size_t i = 0; i < v.current_limit_continuous_amps.size(); ++i)
    {
      s << indent << "  current_limit_continuous_amps[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.current_limit_continuous_amps[i]);
    }
    s << indent << "current_limit_enable[]" << std::endl;
    for (size_t i = 0; i < v.current_limit_enable.size(); ++i)
    {
      s << indent << "  current_limit_enable[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.current_limit_enable[i]);
    }
    s << indent << "motion_cruise_velocity[]" << std::endl;
    for (size_t i = 0; i < v.motion_cruise_velocity.size(); ++i)
    {
      s << indent << "  motion_cruise_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.motion_cruise_velocity[i]);
    }
    s << indent << "motion_acceleration[]" << std::endl;
    for (size_t i = 0; i < v.motion_acceleration.size(); ++i)
    {
      s << indent << "  motion_acceleration[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.motion_acceleration[i]);
    }
    s << indent << "motion_s_curve_strength[]" << std::endl;
    for (size_t i = 0; i < v.motion_s_curve_strength.size(); ++i)
    {
      s << indent << "  motion_s_curve_strength[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_s_curve_strength[i]);
    }
    s << indent << "status_1_general_period[]" << std::endl;
    for (size_t i = 0; i < v.status_1_general_period.size(); ++i)
    {
      s << indent << "  status_1_general_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_1_general_period[i]);
    }
    s << indent << "status_2_feedback0_period[]" << std::endl;
    for (size_t i = 0; i < v.status_2_feedback0_period.size(); ++i)
    {
      s << indent << "  status_2_feedback0_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_2_feedback0_period[i]);
    }
    s << indent << "status_3_quadrature_period[]" << std::endl;
    for (size_t i = 0; i < v.status_3_quadrature_period.size(); ++i)
    {
      s << indent << "  status_3_quadrature_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_3_quadrature_period[i]);
    }
    s << indent << "status_4_aintempvbat_period[]" << std::endl;
    for (size_t i = 0; i < v.status_4_aintempvbat_period.size(); ++i)
    {
      s << indent << "  status_4_aintempvbat_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_4_aintempvbat_period[i]);
    }
    s << indent << "status_6_misc_period[]" << std::endl;
    for (size_t i = 0; i < v.status_6_misc_period.size(); ++i)
    {
      s << indent << "  status_6_misc_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_6_misc_period[i]);
    }
    s << indent << "status_7_commstatus_period[]" << std::endl;
    for (size_t i = 0; i < v.status_7_commstatus_period.size(); ++i)
    {
      s << indent << "  status_7_commstatus_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_7_commstatus_period[i]);
    }
    s << indent << "status_8_pulsewidth_period[]" << std::endl;
    for (size_t i = 0; i < v.status_8_pulsewidth_period.size(); ++i)
    {
      s << indent << "  status_8_pulsewidth_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_8_pulsewidth_period[i]);
    }
    s << indent << "status_9_motprofbuffer_period[]" << std::endl;
    for (size_t i = 0; i < v.status_9_motprofbuffer_period.size(); ++i)
    {
      s << indent << "  status_9_motprofbuffer_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_9_motprofbuffer_period[i]);
    }
    s << indent << "status_10_motionmagic_period[]" << std::endl;
    for (size_t i = 0; i < v.status_10_motionmagic_period.size(); ++i)
    {
      s << indent << "  status_10_motionmagic_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_10_motionmagic_period[i]);
    }
    s << indent << "status_11_uartgadgeteer_period[]" << std::endl;
    for (size_t i = 0; i < v.status_11_uartgadgeteer_period.size(); ++i)
    {
      s << indent << "  status_11_uartgadgeteer_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_11_uartgadgeteer_period[i]);
    }
    s << indent << "status_12_feedback1_period[]" << std::endl;
    for (size_t i = 0; i < v.status_12_feedback1_period.size(); ++i)
    {
      s << indent << "  status_12_feedback1_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_12_feedback1_period[i]);
    }
    s << indent << "status_13_base_pidf0_period[]" << std::endl;
    for (size_t i = 0; i < v.status_13_base_pidf0_period.size(); ++i)
    {
      s << indent << "  status_13_base_pidf0_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_13_base_pidf0_period[i]);
    }
    s << indent << "status_14_turn_pidf1_period[]" << std::endl;
    for (size_t i = 0; i < v.status_14_turn_pidf1_period.size(); ++i)
    {
      s << indent << "  status_14_turn_pidf1_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_14_turn_pidf1_period[i]);
    }
    s << indent << "status_15_firmwareapistatus_period[]" << std::endl;
    for (size_t i = 0; i < v.status_15_firmwareapistatus_period.size(); ++i)
    {
      s << indent << "  status_15_firmwareapistatus_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status_15_firmwareapistatus_period[i]);
    }
    s << indent << "control_3_general_period[]" << std::endl;
    for (size_t i = 0; i < v.control_3_general_period.size(); ++i)
    {
      s << indent << "  control_3_general_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.control_3_general_period[i]);
    }
    s << indent << "control_4_advanced_period[]" << std::endl;
    for (size_t i = 0; i < v.control_4_advanced_period.size(); ++i)
    {
      s << indent << "  control_4_advanced_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.control_4_advanced_period[i]);
    }
    s << indent << "control_5_feedbackoutputoverride_period[]" << std::endl;
    for (size_t i = 0; i < v.control_5_feedbackoutputoverride_period.size(); ++i)
    {
      s << indent << "  control_5_feedbackoutputoverride_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.control_5_feedbackoutputoverride_period[i]);
    }
    s << indent << "control_6_motprofaddtrajpoint_period[]" << std::endl;
    for (size_t i = 0; i < v.control_6_motprofaddtrajpoint_period.size(); ++i)
    {
      s << indent << "  control_6_motprofaddtrajpoint_period[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.control_6_motprofaddtrajpoint_period[i]);
    }
    s << indent << "motion_profile_trajectory_period[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_trajectory_period.size(); ++i)
    {
      s << indent << "  motion_profile_trajectory_period[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.motion_profile_trajectory_period[i]);
    }
    s << indent << "conversion_factor[]" << std::endl;
    for (size_t i = 0; i < v.conversion_factor.size(); ++i)
    {
      s << indent << "  conversion_factor[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.conversion_factor[i]);
    }
    s << indent << "firmware_version[]" << std::endl;
    for (size_t i = 0; i < v.firmware_version.size(); ++i)
    {
      s << indent << "  firmware_version[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.firmware_version[i]);
    }
    s << indent << "water_game[]" << std::endl;
    for (size_t i = 0; i < v.water_game.size(); ++i)
    {
      s << indent << "  water_game[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.water_game[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // TALON_STATE_MSGS_MESSAGE_TALONCONFIG_H
