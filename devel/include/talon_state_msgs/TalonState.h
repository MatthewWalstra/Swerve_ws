// Generated by gencpp from file talon_state_msgs/TalonState.msg
// DO NOT EDIT!


#ifndef TALON_STATE_MSGS_MESSAGE_TALONSTATE_H
#define TALON_STATE_MSGS_MESSAGE_TALONSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <talon_state_msgs/CustomProfileStatus.h>

namespace talon_state_msgs
{
template <class ContainerAllocator>
struct TalonState_
{
  typedef TalonState_<ContainerAllocator> Type;

  TalonState_()
    : header()
    , name()
    , talon_mode()
    , demand1_type()
    , demand1_value()
    , position()
    , speed()
    , output_voltage()
    , output_current()
    , bus_voltage()
    , motor_output_percent()
    , temperature()
    , set_point()
    , closed_loop_error()
    , integral_accumulator()
    , error_derivative()
    , closed_loop_target()
    , p_term()
    , i_term()
    , d_term()
    , f_term()
    , active_trajectory_position()
    , active_trajectory_velocity()
    , active_trajectory_arbitrary_feed_forward()
    , active_trajectory_heading()
    , forward_limit_switch()
    , reverse_limit_switch()
    , forward_softlimit()
    , reverse_softlimit()
    , neutral_output()
    , motion_profile_top_level_buffer_count()
    , motion_profile_top_level_buffer_full()
    , motion_profile_status_top_buffer_rem()
    , motion_profile_status_top_buffer_cnt()
    , motion_profile_status_btm_buffer_cnt()
    , motion_profile_status_has_underrun()
    , motion_profile_status_is_underrun()
    , motion_profile_status_active_point_valid()
    , motion_profile_status_is_last()
    , motion_profile_status_profile_slot_select0()
    , motion_profile_status_profile_slot_select1()
    , motion_profile_status_output_enable()
    , motion_profile_time_dur_ms()
    , faults()
    , sticky_faults()
    , conversion_factor()
    , custom_profile_status()  {
    }
  TalonState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , name(_alloc)
    , talon_mode(_alloc)
    , demand1_type(_alloc)
    , demand1_value(_alloc)
    , position(_alloc)
    , speed(_alloc)
    , output_voltage(_alloc)
    , output_current(_alloc)
    , bus_voltage(_alloc)
    , motor_output_percent(_alloc)
    , temperature(_alloc)
    , set_point(_alloc)
    , closed_loop_error(_alloc)
    , integral_accumulator(_alloc)
    , error_derivative(_alloc)
    , closed_loop_target(_alloc)
    , p_term(_alloc)
    , i_term(_alloc)
    , d_term(_alloc)
    , f_term(_alloc)
    , active_trajectory_position(_alloc)
    , active_trajectory_velocity(_alloc)
    , active_trajectory_arbitrary_feed_forward(_alloc)
    , active_trajectory_heading(_alloc)
    , forward_limit_switch(_alloc)
    , reverse_limit_switch(_alloc)
    , forward_softlimit(_alloc)
    , reverse_softlimit(_alloc)
    , neutral_output(_alloc)
    , motion_profile_top_level_buffer_count(_alloc)
    , motion_profile_top_level_buffer_full(_alloc)
    , motion_profile_status_top_buffer_rem(_alloc)
    , motion_profile_status_top_buffer_cnt(_alloc)
    , motion_profile_status_btm_buffer_cnt(_alloc)
    , motion_profile_status_has_underrun(_alloc)
    , motion_profile_status_is_underrun(_alloc)
    , motion_profile_status_active_point_valid(_alloc)
    , motion_profile_status_is_last(_alloc)
    , motion_profile_status_profile_slot_select0(_alloc)
    , motion_profile_status_profile_slot_select1(_alloc)
    , motion_profile_status_output_enable(_alloc)
    , motion_profile_time_dur_ms(_alloc)
    , faults(_alloc)
    , sticky_faults(_alloc)
    , conversion_factor(_alloc)
    , custom_profile_status(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _name_type;
  _name_type name;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _talon_mode_type;
  _talon_mode_type talon_mode;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _demand1_type_type;
  _demand1_type_type demand1_type;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _demand1_value_type;
  _demand1_value_type demand1_value;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _position_type;
  _position_type position;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _speed_type;
  _speed_type speed;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _output_voltage_type;
  _output_voltage_type output_voltage;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _output_current_type;
  _output_current_type output_current;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _bus_voltage_type;
  _bus_voltage_type bus_voltage;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _motor_output_percent_type;
  _motor_output_percent_type motor_output_percent;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _temperature_type;
  _temperature_type temperature;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _set_point_type;
  _set_point_type set_point;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _closed_loop_error_type;
  _closed_loop_error_type closed_loop_error;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _integral_accumulator_type;
  _integral_accumulator_type integral_accumulator;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _error_derivative_type;
  _error_derivative_type error_derivative;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _closed_loop_target_type;
  _closed_loop_target_type closed_loop_target;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _p_term_type;
  _p_term_type p_term;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _i_term_type;
  _i_term_type i_term;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _d_term_type;
  _d_term_type d_term;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _f_term_type;
  _f_term_type f_term;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _active_trajectory_position_type;
  _active_trajectory_position_type active_trajectory_position;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _active_trajectory_velocity_type;
  _active_trajectory_velocity_type active_trajectory_velocity;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _active_trajectory_arbitrary_feed_forward_type;
  _active_trajectory_arbitrary_feed_forward_type active_trajectory_arbitrary_feed_forward;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _active_trajectory_heading_type;
  _active_trajectory_heading_type active_trajectory_heading;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _forward_limit_switch_type;
  _forward_limit_switch_type forward_limit_switch;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _reverse_limit_switch_type;
  _reverse_limit_switch_type reverse_limit_switch;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _forward_softlimit_type;
  _forward_softlimit_type forward_softlimit;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _reverse_softlimit_type;
  _reverse_softlimit_type reverse_softlimit;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _neutral_output_type;
  _neutral_output_type neutral_output;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_top_level_buffer_count_type;
  _motion_profile_top_level_buffer_count_type motion_profile_top_level_buffer_count;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_profile_top_level_buffer_full_type;
  _motion_profile_top_level_buffer_full_type motion_profile_top_level_buffer_full;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_status_top_buffer_rem_type;
  _motion_profile_status_top_buffer_rem_type motion_profile_status_top_buffer_rem;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_status_top_buffer_cnt_type;
  _motion_profile_status_top_buffer_cnt_type motion_profile_status_top_buffer_cnt;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_status_btm_buffer_cnt_type;
  _motion_profile_status_btm_buffer_cnt_type motion_profile_status_btm_buffer_cnt;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_profile_status_has_underrun_type;
  _motion_profile_status_has_underrun_type motion_profile_status_has_underrun;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_profile_status_is_underrun_type;
  _motion_profile_status_is_underrun_type motion_profile_status_is_underrun;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_profile_status_active_point_valid_type;
  _motion_profile_status_active_point_valid_type motion_profile_status_active_point_valid;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _motion_profile_status_is_last_type;
  _motion_profile_status_is_last_type motion_profile_status_is_last;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_status_profile_slot_select0_type;
  _motion_profile_status_profile_slot_select0_type motion_profile_status_profile_slot_select0;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_status_profile_slot_select1_type;
  _motion_profile_status_profile_slot_select1_type motion_profile_status_profile_slot_select1;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _motion_profile_status_output_enable_type;
  _motion_profile_status_output_enable_type motion_profile_status_output_enable;

   typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _motion_profile_time_dur_ms_type;
  _motion_profile_time_dur_ms_type motion_profile_time_dur_ms;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _faults_type;
  _faults_type faults;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _sticky_faults_type;
  _sticky_faults_type sticky_faults;

   typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _conversion_factor_type;
  _conversion_factor_type conversion_factor;

   typedef std::vector< ::talon_state_msgs::CustomProfileStatus_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::talon_state_msgs::CustomProfileStatus_<ContainerAllocator> >::other >  _custom_profile_status_type;
  _custom_profile_status_type custom_profile_status;





  typedef boost::shared_ptr< ::talon_state_msgs::TalonState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::talon_state_msgs::TalonState_<ContainerAllocator> const> ConstPtr;

}; // struct TalonState_

typedef ::talon_state_msgs::TalonState_<std::allocator<void> > TalonState;

typedef boost::shared_ptr< ::talon_state_msgs::TalonState > TalonStatePtr;
typedef boost::shared_ptr< ::talon_state_msgs::TalonState const> TalonStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::talon_state_msgs::TalonState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::talon_state_msgs::TalonState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::talon_state_msgs::TalonState_<ContainerAllocator1> & lhs, const ::talon_state_msgs::TalonState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.name == rhs.name &&
    lhs.talon_mode == rhs.talon_mode &&
    lhs.demand1_type == rhs.demand1_type &&
    lhs.demand1_value == rhs.demand1_value &&
    lhs.position == rhs.position &&
    lhs.speed == rhs.speed &&
    lhs.output_voltage == rhs.output_voltage &&
    lhs.output_current == rhs.output_current &&
    lhs.bus_voltage == rhs.bus_voltage &&
    lhs.motor_output_percent == rhs.motor_output_percent &&
    lhs.temperature == rhs.temperature &&
    lhs.set_point == rhs.set_point &&
    lhs.closed_loop_error == rhs.closed_loop_error &&
    lhs.integral_accumulator == rhs.integral_accumulator &&
    lhs.error_derivative == rhs.error_derivative &&
    lhs.closed_loop_target == rhs.closed_loop_target &&
    lhs.p_term == rhs.p_term &&
    lhs.i_term == rhs.i_term &&
    lhs.d_term == rhs.d_term &&
    lhs.f_term == rhs.f_term &&
    lhs.active_trajectory_position == rhs.active_trajectory_position &&
    lhs.active_trajectory_velocity == rhs.active_trajectory_velocity &&
    lhs.active_trajectory_arbitrary_feed_forward == rhs.active_trajectory_arbitrary_feed_forward &&
    lhs.active_trajectory_heading == rhs.active_trajectory_heading &&
    lhs.forward_limit_switch == rhs.forward_limit_switch &&
    lhs.reverse_limit_switch == rhs.reverse_limit_switch &&
    lhs.forward_softlimit == rhs.forward_softlimit &&
    lhs.reverse_softlimit == rhs.reverse_softlimit &&
    lhs.neutral_output == rhs.neutral_output &&
    lhs.motion_profile_top_level_buffer_count == rhs.motion_profile_top_level_buffer_count &&
    lhs.motion_profile_top_level_buffer_full == rhs.motion_profile_top_level_buffer_full &&
    lhs.motion_profile_status_top_buffer_rem == rhs.motion_profile_status_top_buffer_rem &&
    lhs.motion_profile_status_top_buffer_cnt == rhs.motion_profile_status_top_buffer_cnt &&
    lhs.motion_profile_status_btm_buffer_cnt == rhs.motion_profile_status_btm_buffer_cnt &&
    lhs.motion_profile_status_has_underrun == rhs.motion_profile_status_has_underrun &&
    lhs.motion_profile_status_is_underrun == rhs.motion_profile_status_is_underrun &&
    lhs.motion_profile_status_active_point_valid == rhs.motion_profile_status_active_point_valid &&
    lhs.motion_profile_status_is_last == rhs.motion_profile_status_is_last &&
    lhs.motion_profile_status_profile_slot_select0 == rhs.motion_profile_status_profile_slot_select0 &&
    lhs.motion_profile_status_profile_slot_select1 == rhs.motion_profile_status_profile_slot_select1 &&
    lhs.motion_profile_status_output_enable == rhs.motion_profile_status_output_enable &&
    lhs.motion_profile_time_dur_ms == rhs.motion_profile_time_dur_ms &&
    lhs.faults == rhs.faults &&
    lhs.sticky_faults == rhs.sticky_faults &&
    lhs.conversion_factor == rhs.conversion_factor &&
    lhs.custom_profile_status == rhs.custom_profile_status;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::talon_state_msgs::TalonState_<ContainerAllocator1> & lhs, const ::talon_state_msgs::TalonState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace talon_state_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::talon_state_msgs::TalonState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::talon_state_msgs::TalonState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::talon_state_msgs::TalonState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::talon_state_msgs::TalonState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::talon_state_msgs::TalonState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::talon_state_msgs::TalonState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::talon_state_msgs::TalonState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3c4ea359830a4aa13b177949e57ebce3";
  }

  static const char* value(const ::talon_state_msgs::TalonState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3c4ea359830a4aa1ULL;
  static const uint64_t static_value2 = 0x3b177949e57ebce3ULL;
};

template<class ContainerAllocator>
struct DataType< ::talon_state_msgs::TalonState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "talon_state_msgs/TalonState";
  }

  static const char* value(const ::talon_state_msgs::TalonState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::talon_state_msgs::TalonState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"string[] name\n"
"string[] talon_mode\n"
"string[] demand1_type\n"
"float64[] demand1_value\n"
"float64[] position\n"
"float64[] speed\n"
"float64[] output_voltage\n"
"float64[] output_current\n"
"float64[] bus_voltage\n"
"float64[] motor_output_percent\n"
"float64[] temperature\n"
"float64[] set_point\n"
"float64[] closed_loop_error\n"
"float64[] integral_accumulator\n"
"float64[] error_derivative\n"
"float64[] closed_loop_target\n"
"float64[] p_term\n"
"float64[] i_term\n"
"float64[] d_term\n"
"float64[] f_term\n"
"float64[] active_trajectory_position\n"
"float64[] active_trajectory_velocity\n"
"float64[] active_trajectory_arbitrary_feed_forward\n"
"float64[] active_trajectory_heading\n"
"bool[] forward_limit_switch\n"
"bool[] reverse_limit_switch\n"
"bool[] forward_softlimit\n"
"bool[] reverse_softlimit\n"
"bool[] neutral_output\n"
"int32[]   motion_profile_top_level_buffer_count\n"
"bool[]    motion_profile_top_level_buffer_full\n"
"int32[]   motion_profile_status_top_buffer_rem\n"
"int32[]   motion_profile_status_top_buffer_cnt\n"
"int32[]   motion_profile_status_btm_buffer_cnt\n"
"bool[]    motion_profile_status_has_underrun\n"
"bool[]    motion_profile_status_is_underrun\n"
"bool[]    motion_profile_status_active_point_valid\n"
"bool[]    motion_profile_status_is_last\n"
"int32[]   motion_profile_status_profile_slot_select0\n"
"int32[]   motion_profile_status_profile_slot_select1\n"
"string[]  motion_profile_status_output_enable\n"
"int32[]   motion_profile_time_dur_ms\n"
"string[]  faults\n"
"string[]  sticky_faults\n"
"float64[] conversion_factor\n"
"talon_state_msgs/CustomProfileStatus[] custom_profile_status\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: talon_state_msgs/CustomProfileStatus\n"
"bool running\n"
"int32 slotRunning\n"
"int32[] remainingPoints\n"
"float64 remainingTime\n"
"bool outOfPoints\n"
;
  }

  static const char* value(const ::talon_state_msgs::TalonState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::talon_state_msgs::TalonState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.name);
      stream.next(m.talon_mode);
      stream.next(m.demand1_type);
      stream.next(m.demand1_value);
      stream.next(m.position);
      stream.next(m.speed);
      stream.next(m.output_voltage);
      stream.next(m.output_current);
      stream.next(m.bus_voltage);
      stream.next(m.motor_output_percent);
      stream.next(m.temperature);
      stream.next(m.set_point);
      stream.next(m.closed_loop_error);
      stream.next(m.integral_accumulator);
      stream.next(m.error_derivative);
      stream.next(m.closed_loop_target);
      stream.next(m.p_term);
      stream.next(m.i_term);
      stream.next(m.d_term);
      stream.next(m.f_term);
      stream.next(m.active_trajectory_position);
      stream.next(m.active_trajectory_velocity);
      stream.next(m.active_trajectory_arbitrary_feed_forward);
      stream.next(m.active_trajectory_heading);
      stream.next(m.forward_limit_switch);
      stream.next(m.reverse_limit_switch);
      stream.next(m.forward_softlimit);
      stream.next(m.reverse_softlimit);
      stream.next(m.neutral_output);
      stream.next(m.motion_profile_top_level_buffer_count);
      stream.next(m.motion_profile_top_level_buffer_full);
      stream.next(m.motion_profile_status_top_buffer_rem);
      stream.next(m.motion_profile_status_top_buffer_cnt);
      stream.next(m.motion_profile_status_btm_buffer_cnt);
      stream.next(m.motion_profile_status_has_underrun);
      stream.next(m.motion_profile_status_is_underrun);
      stream.next(m.motion_profile_status_active_point_valid);
      stream.next(m.motion_profile_status_is_last);
      stream.next(m.motion_profile_status_profile_slot_select0);
      stream.next(m.motion_profile_status_profile_slot_select1);
      stream.next(m.motion_profile_status_output_enable);
      stream.next(m.motion_profile_time_dur_ms);
      stream.next(m.faults);
      stream.next(m.sticky_faults);
      stream.next(m.conversion_factor);
      stream.next(m.custom_profile_status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TalonState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::talon_state_msgs::TalonState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::talon_state_msgs::TalonState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "name[]" << std::endl;
    for (size_t i = 0; i < v.name.size(); ++i)
    {
      s << indent << "  name[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.name[i]);
    }
    s << indent << "talon_mode[]" << std::endl;
    for (size_t i = 0; i < v.talon_mode.size(); ++i)
    {
      s << indent << "  talon_mode[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.talon_mode[i]);
    }
    s << indent << "demand1_type[]" << std::endl;
    for (size_t i = 0; i < v.demand1_type.size(); ++i)
    {
      s << indent << "  demand1_type[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.demand1_type[i]);
    }
    s << indent << "demand1_value[]" << std::endl;
    for (size_t i = 0; i < v.demand1_value.size(); ++i)
    {
      s << indent << "  demand1_value[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.demand1_value[i]);
    }
    s << indent << "position[]" << std::endl;
    for (size_t i = 0; i < v.position.size(); ++i)
    {
      s << indent << "  position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.position[i]);
    }
    s << indent << "speed[]" << std::endl;
    for (size_t i = 0; i < v.speed.size(); ++i)
    {
      s << indent << "  speed[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.speed[i]);
    }
    s << indent << "output_voltage[]" << std::endl;
    for (size_t i = 0; i < v.output_voltage.size(); ++i)
    {
      s << indent << "  output_voltage[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.output_voltage[i]);
    }
    s << indent << "output_current[]" << std::endl;
    for (size_t i = 0; i < v.output_current.size(); ++i)
    {
      s << indent << "  output_current[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.output_current[i]);
    }
    s << indent << "bus_voltage[]" << std::endl;
    for (size_t i = 0; i < v.bus_voltage.size(); ++i)
    {
      s << indent << "  bus_voltage[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.bus_voltage[i]);
    }
    s << indent << "motor_output_percent[]" << std::endl;
    for (size_t i = 0; i < v.motor_output_percent.size(); ++i)
    {
      s << indent << "  motor_output_percent[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.motor_output_percent[i]);
    }
    s << indent << "temperature[]" << std::endl;
    for (size_t i = 0; i < v.temperature.size(); ++i)
    {
      s << indent << "  temperature[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.temperature[i]);
    }
    s << indent << "set_point[]" << std::endl;
    for (size_t i = 0; i < v.set_point.size(); ++i)
    {
      s << indent << "  set_point[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.set_point[i]);
    }
    s << indent << "closed_loop_error[]" << std::endl;
    for (size_t i = 0; i < v.closed_loop_error.size(); ++i)
    {
      s << indent << "  closed_loop_error[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.closed_loop_error[i]);
    }
    s << indent << "integral_accumulator[]" << std::endl;
    for (size_t i = 0; i < v.integral_accumulator.size(); ++i)
    {
      s << indent << "  integral_accumulator[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.integral_accumulator[i]);
    }
    s << indent << "error_derivative[]" << std::endl;
    for (size_t i = 0; i < v.error_derivative.size(); ++i)
    {
      s << indent << "  error_derivative[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.error_derivative[i]);
    }
    s << indent << "closed_loop_target[]" << std::endl;
    for (size_t i = 0; i < v.closed_loop_target.size(); ++i)
    {
      s << indent << "  closed_loop_target[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.closed_loop_target[i]);
    }
    s << indent << "p_term[]" << std::endl;
    for (size_t i = 0; i < v.p_term.size(); ++i)
    {
      s << indent << "  p_term[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.p_term[i]);
    }
    s << indent << "i_term[]" << std::endl;
    for (size_t i = 0; i < v.i_term.size(); ++i)
    {
      s << indent << "  i_term[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.i_term[i]);
    }
    s << indent << "d_term[]" << std::endl;
    for (size_t i = 0; i < v.d_term.size(); ++i)
    {
      s << indent << "  d_term[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.d_term[i]);
    }
    s << indent << "f_term[]" << std::endl;
    for (size_t i = 0; i < v.f_term.size(); ++i)
    {
      s << indent << "  f_term[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.f_term[i]);
    }
    s << indent << "active_trajectory_position[]" << std::endl;
    for (size_t i = 0; i < v.active_trajectory_position.size(); ++i)
    {
      s << indent << "  active_trajectory_position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.active_trajectory_position[i]);
    }
    s << indent << "active_trajectory_velocity[]" << std::endl;
    for (size_t i = 0; i < v.active_trajectory_velocity.size(); ++i)
    {
      s << indent << "  active_trajectory_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.active_trajectory_velocity[i]);
    }
    s << indent << "active_trajectory_arbitrary_feed_forward[]" << std::endl;
    for (size_t i = 0; i < v.active_trajectory_arbitrary_feed_forward.size(); ++i)
    {
      s << indent << "  active_trajectory_arbitrary_feed_forward[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.active_trajectory_arbitrary_feed_forward[i]);
    }
    s << indent << "active_trajectory_heading[]" << std::endl;
    for (size_t i = 0; i < v.active_trajectory_heading.size(); ++i)
    {
      s << indent << "  active_trajectory_heading[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.active_trajectory_heading[i]);
    }
    s << indent << "forward_limit_switch[]" << std::endl;
    for (size_t i = 0; i < v.forward_limit_switch.size(); ++i)
    {
      s << indent << "  forward_limit_switch[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.forward_limit_switch[i]);
    }
    s << indent << "reverse_limit_switch[]" << std::endl;
    for (size_t i = 0; i < v.reverse_limit_switch.size(); ++i)
    {
      s << indent << "  reverse_limit_switch[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reverse_limit_switch[i]);
    }
    s << indent << "forward_softlimit[]" << std::endl;
    for (size_t i = 0; i < v.forward_softlimit.size(); ++i)
    {
      s << indent << "  forward_softlimit[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.forward_softlimit[i]);
    }
    s << indent << "reverse_softlimit[]" << std::endl;
    for (size_t i = 0; i < v.reverse_softlimit.size(); ++i)
    {
      s << indent << "  reverse_softlimit[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.reverse_softlimit[i]);
    }
    s << indent << "neutral_output[]" << std::endl;
    for (size_t i = 0; i < v.neutral_output.size(); ++i)
    {
      s << indent << "  neutral_output[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.neutral_output[i]);
    }
    s << indent << "motion_profile_top_level_buffer_count[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_top_level_buffer_count.size(); ++i)
    {
      s << indent << "  motion_profile_top_level_buffer_count[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_top_level_buffer_count[i]);
    }
    s << indent << "motion_profile_top_level_buffer_full[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_top_level_buffer_full.size(); ++i)
    {
      s << indent << "  motion_profile_top_level_buffer_full[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_profile_top_level_buffer_full[i]);
    }
    s << indent << "motion_profile_status_top_buffer_rem[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_top_buffer_rem.size(); ++i)
    {
      s << indent << "  motion_profile_status_top_buffer_rem[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_status_top_buffer_rem[i]);
    }
    s << indent << "motion_profile_status_top_buffer_cnt[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_top_buffer_cnt.size(); ++i)
    {
      s << indent << "  motion_profile_status_top_buffer_cnt[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_status_top_buffer_cnt[i]);
    }
    s << indent << "motion_profile_status_btm_buffer_cnt[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_btm_buffer_cnt.size(); ++i)
    {
      s << indent << "  motion_profile_status_btm_buffer_cnt[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_status_btm_buffer_cnt[i]);
    }
    s << indent << "motion_profile_status_has_underrun[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_has_underrun.size(); ++i)
    {
      s << indent << "  motion_profile_status_has_underrun[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_profile_status_has_underrun[i]);
    }
    s << indent << "motion_profile_status_is_underrun[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_is_underrun.size(); ++i)
    {
      s << indent << "  motion_profile_status_is_underrun[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_profile_status_is_underrun[i]);
    }
    s << indent << "motion_profile_status_active_point_valid[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_active_point_valid.size(); ++i)
    {
      s << indent << "  motion_profile_status_active_point_valid[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_profile_status_active_point_valid[i]);
    }
    s << indent << "motion_profile_status_is_last[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_is_last.size(); ++i)
    {
      s << indent << "  motion_profile_status_is_last[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.motion_profile_status_is_last[i]);
    }
    s << indent << "motion_profile_status_profile_slot_select0[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_profile_slot_select0.size(); ++i)
    {
      s << indent << "  motion_profile_status_profile_slot_select0[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_status_profile_slot_select0[i]);
    }
    s << indent << "motion_profile_status_profile_slot_select1[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_profile_slot_select1.size(); ++i)
    {
      s << indent << "  motion_profile_status_profile_slot_select1[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_status_profile_slot_select1[i]);
    }
    s << indent << "motion_profile_status_output_enable[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_status_output_enable.size(); ++i)
    {
      s << indent << "  motion_profile_status_output_enable[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.motion_profile_status_output_enable[i]);
    }
    s << indent << "motion_profile_time_dur_ms[]" << std::endl;
    for (size_t i = 0; i < v.motion_profile_time_dur_ms.size(); ++i)
    {
      s << indent << "  motion_profile_time_dur_ms[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.motion_profile_time_dur_ms[i]);
    }
    s << indent << "faults[]" << std::endl;
    for (size_t i = 0; i < v.faults.size(); ++i)
    {
      s << indent << "  faults[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.faults[i]);
    }
    s << indent << "sticky_faults[]" << std::endl;
    for (size_t i = 0; i < v.sticky_faults.size(); ++i)
    {
      s << indent << "  sticky_faults[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.sticky_faults[i]);
    }
    s << indent << "conversion_factor[]" << std::endl;
    for (size_t i = 0; i < v.conversion_factor.size(); ++i)
    {
      s << indent << "  conversion_factor[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.conversion_factor[i]);
    }
    s << indent << "custom_profile_status[]" << std::endl;
    for (size_t i = 0; i < v.custom_profile_status.size(); ++i)
    {
      s << indent << "  custom_profile_status[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::talon_state_msgs::CustomProfileStatus_<ContainerAllocator> >::stream(s, indent + "    ", v.custom_profile_status[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // TALON_STATE_MSGS_MESSAGE_TALONSTATE_H
